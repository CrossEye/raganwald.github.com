---
title: "Ayoayo (unfinished)"
tags: [recursion,allonge]
---

**WARNING:** *This is an unfinished post, temporarily shared for preview and feedback purposes. The URL will expire in 24 hours. Feel free to share it on Twitter, but please do not post it on aggregator sites like Hacker News or Reddit: Those communities prefer to evaluate the finished work.*

---

> [Oware] is an abstract strategy game among the [Mancala] family of board games (pit and pebble games) played worldwide with slight variations as to the layout of the game, number of players and strategy of play. Its origin is uncertain, but it is widely believed to be of [Ashanti] origin.
>
> Played in the Ashanti Region and throughout the Caribbean, Oware and its variants have many names. The Yoruba people of Nigeria call their version of the game **[Ayoayo]**.

[Oware]: https://en.wikipedia.org/wiki/Oware
[Mancala]: https://en.wikipedia.org/wiki/Mancala
[Ashanti]: https://en.wikipedia.org/wiki/Ashanti_Empire
[Ayoayo]: https://en.wikipedia.org/wiki/Ayoayo

---

[![Mancala / Awale](/assets/images/ayoayo/2.jpg)](https://www.flickr.com/photos/elpadawan/8479297425/)

---

### ayoayo

Ayoayo is played on the most common layout, a board with two rows of six pits. Many boards also provide with a pit on each side of the board for "captured" stones, but this is optional when playing Ayoayo.

The players face each other with the board between them, such that each player has a row of six pits in front of them. These pits "belong" to that player. If extra pits are provided for captured stones, each player takes one for themselves, but the extra pits are not in play. (In some other games in the same family, pits for captured stones are used in play.)

We've mentioned capturing stones several times, and for good reason: The game play consists of capturing stones, and when the game is completed, the player who has captured the most stones, wins.

The rules are simple:

*The game begins with four stones in each of the twelve pits. Thus, the game requires 48 stones. Pebbles, marbles, or even lego pieces can be used to represent the stones. A wooden board is nice, but pits can be scooped out of earth or sand to make a board. This extreme simplicity is part of the game's charm, much as tic-tac-toe's popularity stems in part from the fact that you can play a game with little more than a stick and a piece of flat earth.*

*The players alternate turns, as in may games.*

*On a player's turn, they select one of their pits to "sow." There are some exceptions listed below, but in general if the player has more than one pit with stones, they may select which one to sow. There are many variations on rules for how to sow the stones amongst the Mancala family of games, but in Ayoayo, sowing works like this:*

- The player scoops all of the stones from the starting pit into their hand.
- Moving counter-clockwise, the player drops one stone into each pit.
- On their row, they move from left to right.
- If they reach the end of their row, they move from right to left on their opponent's row (thus "counter-clockwise").
- They always skip the starting pit on their row.
- The sowing pauses when they have sowed the last stone in their hand.

*If the last stone lands in a pit on either side of the board that contains one or more stones, they scoop the stones up (including that last stone), and continue sowing. They continue to skip their original starting pit only, but can sow into any pits that get scooped up in this manner. This is called **relay sowing**.*

*If the last stone lands in an empty pit **on that player's own side**, the player "captures" any stones that are in the pit on the opponent's side of the board from their last pit.*

*If a player has no move on their turn, the game ends, and their opponent captures any remaining stones (which will--of course--be on their side)*.

*If a player is able to make a move that leaves their opponent with one or more moves to make, they must make a move that leaves their opponent with one or more moves to make. If a player has several such moves (as is usually the case), the player may choose which move to make.*

If we were going to make an Ayoayo program, where would we start?

---

[![Natural Mancala Game](/assets/images/ayoayo/1.jpg)](https://www.flickr.com/photos/candiedwomanire/104320826)

---

### sowing stones

Let's start with a simple idea: We'll have to represent the state of the game. We could use an array for the twelve pits of the game, with an integer representing the number of stones in that put. We'll initialize it with four stones in each pit:

```javascript
const gamePits = Array(12).fill(4);
```

We'll associate the elements of the array with the pits belonging to the players.

[![Associating array elements with pits](/assets/images/ayoayo/3.png)](https://www.flickr.com/photos/narasclicks/4654106883/)

In Ayoayo, a full turn involves *relay sowing* as described above:

> When relay sowing, if the last stone during sowing lands in an occupied hole, all the contents of that hole, including the last sown stone, are immediately re-sown from the hole.

The other kind of sowing, as used in other games from the same family, is just called _sowing_. The sowing stops when the last stone is sown, regardless of whether the last stone lands in an occupied or unoccupied pit.

It's fairly obvious that if we make a function for sowing, we can use that to make a function for relay sowing, so let's start with an ordinary sowing function. We'll make a relay sowing function later.

The first thing we need is a function to scoop up the stones from a pit:

```javascript
function scoop(fromPit) {
  const stonesInHand = gamePits[fromPit];

  gamePits[fromPit] = 0;

  return stonesInHand;
}
```

We'll also need a function to distribute stones. It needs to know which pit to skip, where to start distributing, and how many stones to are in the hand that need to be distributed:

```javascript
function distribute(skipPit, currentPit, stonesInHand) {

  // now what?

}
```

The first thing our `distrubute` function needs to do is place a stone from the hand into the current pit. With a wrinkle that if the current pit is the skip pit, move to the next pit:


```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  // And now what?
}
```

What should we do next?

Well, if we don't have any more stones in hand, we're done. We should return the current pit so that other code can do things like work out whether to continue sowing, or determine whether to capture any stones from our opponent:

```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    // what goes here?
  }
}
```

If we still have stones, then what? We need to keep sowing. We *could* rewrite `distribute` to have a loop of so kind, maybe `do { ... } while (...)`. But hang on!

`distribute` is a function that takes a pit to skip, a current pit, and a number of stones in hand. It returns the result of sowing stones. That's what we need to return, with just one alteration: We need distribute starting with the next pit. So let's just do that:

```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    return distribute(skipPit, nextPit(currentPit), stonesInHand);
  }
}
```

With `scoop` and `distribute`, we can write `sow`:

```javascript
function sow(skipPit, fromPit = skipPit) {
  return distribute(skipPit, nextPit(fromPit), scoop(fromPit));
}
```

Let's try it:

```javascript
sow(0)
  //=> 4

gamePits
  //=> [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4]
```

We can test it by hand. We start with the board looking like this:

![initial position](/assets/images/ayoayo/4.jpg)

And after sowing once, it looks like this:

![position after sowing from position zero](/assets/images/ayoayo/5.jpg)

Now, there were five stones in the last pit (pit `4`). If there are two or more stones in the last pit, it wasn't empty before we sowed the last stone into it. So when relay sowing, we'd sow again, only this time we'll tell our function start at pit `4`, where we left off last time:

```javascript
sow(0, 4)
  //=> 9
```

Five stones in the last pit (`9`), Let's do it again:

```javascript
sow(0, 9)
  //=> 3
```

Six stones in pit `3`! Again:

```javascript
sow(0, 3)
  //=> 9

pits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

Aha, just one stone in pit `9`, we're done. Let's try it by hand, remembering to skip pit `0`, and compare:

![position after relay sowing from position zero](/assets/images/ayoayo/6.jpg)

Let's look at our accumulated code all together:

```javascript
function scoop(fromPit) {
  const stonesInHand = gamePits[fromPit];

  gamePits[fromPit] = 0;

  return stonesInHand;
}

function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    return distribute(skipPit, nextPit(currentPit), stonesInHand);
  }
}

function sow(skipPit, fromPit = skipPit) {
  return distribute(skipPit, nextPit(fromPit), scoop(fromPit));
}

let gamePits = Array(12).fill(4);

sow(0)
  //=> 4
sow(0, 4)
  //=> 9
sow(0, 9)
  //=> 3
sow(0, 3)
  //=> 9

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We're off to a reasonable start. And as it happens, the recursive solution is actually straightforward to explain and to implement.

---

[![Toghiz Qumalaq](/assets/images/ayoayo/toghiz-qumalaq.jpg)](https://www.flickr.com/photos/upyernoz/5662602383)

> [Toguz korgool](https://en.wikipedia.org/wiki/Toguz_korgol) (Kyrgyz: тогуз коргоол - "nine sheep droppings") or toguz kumalak/toghiz qumalaq (Kazakh: тоғыз құмалақ), is a two-player game in the mancala family that is played in Central Asia.

---

### a most practical consideration

Let's look at our calls to `sow` again:

```javascript
sow(0)
sow(0, 4)
sow(0, 9)
sow(0, 3)
 ```

Shall we try it again?

```javascript
sow(0)
  //=> undefined
```

D'oh! We forgot to reset the board. Our `sow` function relies upon a mutable value from outside of its body--`gamePits`--and indeed it mutates that value by changing the contents of the array. Thus, when you invoke `sow`, you don't know what you're going to get unless you already know the state of `gamePits`.

We say that `sow` is *coupled* to `gamePits`. In order to test `sow`, we have to first carefully set up `gamePits` to align with our expectations. We see this kind of thing when writing production code for large systems: Many tests do more work setting up and tearing down all of the required initial conditions than they do actually testing functions and methods.

So coupling a function to a mutable value requires us to keep track of that value in order to understand what `sow` will or won't do. That adds some complexity to understanding our system. And this coupling is *transitive*: Not only is `sow` coupled to `gamePits`, any other function we write that is coupled to `gamePits`, becomes coupled to `sow`. Running `sow` changes the behaviour of any  function coupled to `gamePits` because `sow` mutates `gamePits`.

In fact, `sow` is coupled to itself! Even if we remember to correctly initialize `gamePits` before running `sow`, the order in which we invoke `sow` affects the results.

Having a single variable, `gamePits`, describing the state of the game in progress does feel intuitively sound. There is only one board in the game, and when we sow stones, we change it. So why shouldn't we "model the real world accurately?"

That question is easy to answer: I used to own a typewriter. It had no "undo." It had no "copy" or "paste," those functions were accomplished by making copies of pages and laboriously cutting sections of text out with an x-acto blade and gluing them onto other pieces of paper. The text editor I am using now is superior to my typewriter precisely because it does not insist on modelling the real world accurately.

Modelling the real world is a tool for exploring ideas in software and for helping others read our software: What is familiar, subjectively feels "intuitive."[^raskin] But when the modelling interferes with our ability to understand our software's behaviour, we should relax our desire to make everything about modelling. What we seek is maximum understandability and maximum flexibility, not maximum fidelity.

So how can we "decouple" or code from itself and each other?

---

[![Two coupled high-speed trains ETR 610 of SBB on the Gotthard line](/assets/images/ayoayo/couplings.jpg)](https://www.flickr.com/photos/kecko/33884931711)

> Picture of a train **coupling**.

---

### decoupling code from shared mutable values

The easiest thing is the obvious thing: If a function shares mutable values with another function (or itself!), and we wish to remove the coupling caused by changes to the shared mutable values, we rewrite the functions to get rid of the shared mutable values. This is an easy refactoring:

- We take all of the references to shared mutable values that functions must read, and replace them with parameters.
- We take all of the references to shared mutable values that functions must write, and replace them with creating *copies* of the shared mutable values. We then return those copies along with any other return values the functions already have.

So our code becomes:

```javascript
function scoop(before, fromPit) {
  const after = before.slice(0);
  const stonesInHand = after[fromPit];

  after[fromPit] = 0;

  return [after, stonesInHand];
}

function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(before, skipPit, currentPit, stonesInHand) {
  const after = before.slice(0);

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++after[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return [after, currentPit];
  } else if (stonesInHand > 0) {
    return distribute(after, skipPit, nextPit(currentPit), stonesInHand);
  }
}

function sow(before, skipPit, fromPit = skipPit) {
  const [after, pitsInHand] = scoop(before, fromPit);

  return distribute(after, skipPit, nextPit(fromPit), pitsInHand);
}
```

And we use it like this:

```javascript
let gamePits = Array(12).fill(4);

sow(gamePits, 0)
  //=> [
         [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4],
         4
       ]
```

If we want to update the game mutable values, we can choose to do that:

```javascript
let gamePits = Array(12).fill(4);
let lastPit;

[gamePits, lastPit] = sow(gamePits, 0);

gamePits
  //=> [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4]
```

Well. At first sight, there seem to be more moving parts with this approach.[^well] But in truth, they were always there, it's just that we "lifted" them into the interface of the `scoop`, `distribute`, and `sow` functions where we can see them. And now, we can test any arbitrary invocation without having to remember to set things up in advance.

[^well]: Well, the "elephant in the room" is the creation and absondonment of copies of arrays. There are several ways to address this issue, but for the moment they are not germane to the direction of the essay. But we may return to it later.

For example, here's the second call we made:

```javascript
sow([0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4], 0, 4)
  //=> [
         [0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 4, 4],
         9
       ]
```

Checks out, and so do the third and fourth calls we made:

```javascript
sow([0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 4, 4], 0, 9)
  //=> [
         [0, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5],
         3
       ]

sow([0, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5], 0, 3)
  //=> [
         [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5],
         9
       ]
```

We get to the same place, but we can run our "tests" in any order and don't have to do any set up in advance.

The lesson learned is that decoupling functions from mutable mutable values makes them easier to understand and test. And if we want to model the "real world" by having a value representing the current game mutable values, we can still do that:

```javascript
let gamePits = Array(12).fill(4);

let initialChoice = 0;
let lastPit;

[gamePits, lastPit] = sow(gamePits, initialChoice);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);

gamePits[lastPit]
  //=> 1

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

Now let's automate the "relay sowing."

---

<iframe width="620" height="349" src="https://www.youtube.com/embed/A4v1WkzY3gA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

> [Relayer] is an album by Prog Rock progenitors Yes. It is notable for being the first album they recorded without Rick Wakeman, who wanted to break from the emphasis on long-form compositions.

[Relayer]: https://en.wikipedia.org/wiki/Relayer

---

### relay sowing

We have implemented "relay sowing" by hand above. It's time to write a `relaySow` function. We could modify `sow`, but accreting new functionality on top of old is a recipe for bloat.

How do we start `relaySow`? Well, with `sow`:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  // what happens next?
}
```

Well, what **does** happen next? I think we know the answer: We need to check and see whether the number of stones in the last pit is one or not:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  if (after[lastPit] === 1) {
    return [after, lastPit];
  } else {
    // now what?
  }
}
```

"Now what," indeed. Now what? We can't just call `sow` again and return the result, that won't work if we end up needing to sow a third time. We'd need all sorts of nested `if` statements. Yecch.

We *could* rewrite `relaySow` to have a loop of so kind, maybe `do { ... } while (...)`. But hang on! With `distribute`, we recursively called `distribute` when there was more work to be done. Let's use the same pattern:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  if (after[lastPit] === 1) {
    return [after, lastPit];
  } else {
    return relaySow(after, skipPit, lastPit);
  }
}

let gamePits = Array(12).fill(4);
let lastPit;

[gamePits, lastPit] = relaySow(gamePits, 0);

lastPit
  //=> 9

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We have relay sowing working. What else do we need to model a player's turn?

---

[![Game of Go at Club Saarto](/assets/images/ayoayo/saarto.jpg)](https://www.flickr.com/photos/jlarnos/37641991971)

> Go is a completely different game from the Mancala family, but they share the notion of capturing stones.

### capturing stones

Relay sowing ends when the last stone is placed in an empty hole. In Ayoayo, if that empty hole is on the player's side, they capture all of the stones in the corresponding hole on the opponent's side:

```javascript
function capturedStones(before, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const after = before.slice(0);
    const stones = after[pitOnOpponentsSide];

    after[pitOnOpponentsSide] = 0;

    return [after, stones];
  } else {
    return [before, 0];
  }
}
```

We will try it:

```javascript
const gameStart = Array(12).fill(4);
const startPit = 0;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, captured] = capturedStones(afterSowing, startPit, endPit);

afterTurn
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]

endPit
  //=> 9

captured
  //=> 0
```

No stones were captured, because the last pit was pit nine on the other side. How can we get a test case that captures stones? Should we try the numbers at random or in sequence? We don't have to. The starting position of the board is symmetrical under rotation. So if move `0` ends up with the board in a certain layout after sowing, and ending on pit `9`, it follows that choosing `1` should lead to exactly the same layout, but rotated one pit counter-clockwise, and the last pit will be `10`.

Well this makes things easy. If the player chooses to start with `3`, the last pit should be `0`, on the player's own side:

```javascript
const gameStart = Array(12).fill(4);
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, captured] = capturedStones(afterSowing, startPit, endPit);

afterSowing
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 6]

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

endPit
  //=> 0

captured
  //=> 6
```

If we want to update the game state, we'll need a notion of a "score," and we can change `capturedStones` into `handleCapture`:

```javascript
function handleCaptures(beforePits, beforeScore, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const afterPits = beforePits.slice(0);
    const playerNumber = startPit > 5 ? 1 : 0;
    const afterScore = Object.assign(
      beforeScore,
      { [playerNumber]: beforeScore[playerNumber] + beforePits[pitOnOpponentsSide] }
    );
    afterPits[pitOnOpponentsSide] = 0;

    return [afterPits, afterScore];
  } else {
    return [beforePits, beforeScore];
  }
}

const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, scoreAfter] = handleCaptures(afterSowing, scoreStart, startPit, endPit);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

scoreAfter
  //=> {0: 6, 1: 0},
```

We now have *almost* everything we need to referee a game between two players. Not enough to write a program to play on its own, but we almost have enough to get going on—for example—a web site that woudl allow players to play each other online. So what are we missing?

Two things: Determining when the game is over, and determining which moves are permissible. The former depends upon the latter, so our next step is to determine which moves a player is allowed to make.

---

[![no entry?](/assets/images/ayoayo/no-entry.jpg)](https://www.flickr.com/photos/lee-yoshi/15368560025)

> In Ayoayo, some moves are permitted, and some are prohibited.

### permissible moves

---

*to be completed*


---

# Notes

[^raskin]: [Intuitive Equals Familiar](https://www.asktog.com/papers/raskinintuit.html), Jef Raskin, 1994