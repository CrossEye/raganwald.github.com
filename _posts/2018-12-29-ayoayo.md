---
title: "Ayoayo (unfinished)"
tags: [recursion,allonge,mermaid]
---

**WARNING:** *This is an unfinished post, temporarily shared for preview and feedback purposes. For example, it lacks a technical introduction: The introduction is usually written after the main ideas are fully fleshed out. Feel free to share this on Twitter, but please do not post it on aggregator sites like Hacker News or Reddit: Those communities prefer to evaluate the finished work.*

---

![Visiting a slave fort in Ghana](/assets/images/ayoayo/fort.jpg)

*I believe this is a picture of my sister and me visiting a fort used to house slaves before their transportation (what a bloodless word) to the Americas, probably in Ghana.*

---

### prelude: africa 1968&thinsp;&ndash;&thinsp;1971

In 1968 or thereabouts, my [mother][womansstory] took my sister and I on a trip to West Africa. We returned to Nigeria a year or so later, and lived there while she developed software for a brand-new IBM 360 that had been installed at the University of Ibadan.

[womansstory]: http://braythwayt.com/posterous/2012/03/29/a-womans-story.html

It is difficult for me to explain the magnitude of the culture shock I experienced in Africa. In the 1960s, Toronto was much less visibly multicultural than it is today. I do not recall ever seeing a black police officer, teacher, or newscaster on television. In 1963, my great-uncle Leonard had become the first black MPP in Canada, but in 1968 he was still more of an exception than a minority.

And then I visited Africa. Almost everyone was black, where in Canada, almost everyone was white. I distinctly recall being amazed to visit the flight deck of our [Air Afrique] flight, and the black pilots let me sit in the co-pilot's chair. The flight attendants were black as well, and everyone spoke French. I had never encountered such a thing.

[Air Afrique]: https://en.wikipedia.org/wiki/Air_Afrique

In Africa, there was fantastic wealth, and there was wretched poverty as I'd never imagined. Many institutions in Africa were older than the country of Canada. That's something you find in most of the old world, like England or Europe, but it was particularly stunning for me to look at things like the [Great Mosque of Djenné]. The first mosque on that site was built in the late 13th century, three centuries before the first Europeans set permanent foot in Canada.

[Great Mosque of Djenné]: https://en.wikipedia.org/wiki/Great_Mosque_of_Djenné

In 1970, we were even in the crowds for the coronation procession of [Opoku Ware II], 15th Emperor-King of the Ashanti people. The Empire of Ashanti was formed in 1701, a century and a half before Canada became a country. My brain exploded when we touched down in Africa, and continued to erupt the entire time we were there. Everything I encountered was literally fantastic.

[Opoku Ware II]: https://en.wikipedia.org/wiki/Opoku_Ware_II

From an early age, my mother had taken our education "in hand," as they used to say. I was already aware of various important stories and facts about black people, like Harriet Tubman. I think I had already read some [Anansi] stories from books she had imported by mail. You wouldn't find things like that in a bookstore in those days.

And amongst all those great things, she may have also introduced me to some form of the game [Oware] in Toronto, but my recollection is that I first encountered it in Africa.

[Anansi]: https://en.wikipedia.org/wiki/Anansi
[Oware]: https://en.wikipedia.org/wiki/Oware

---

[![Mancala / Awale / Oware / Ayoayo](/assets/images/ayoayo/board.jpg)](https://www.flickr.com/photos/elpadawan/8479297425/)

*This board can be used to play many different kinds of Oware, including Ayoayo.*

---

### oware and ayoayo

What is Oware? Wikipedia puts it succinctly and well: [Oware] is an abstract strategy game among the [Mancala] family of board games (pit and pebble games) played worldwide with slight variations as to the layout of the game, number of players and strategy of play. Its origin is uncertain, but it is widely believed to be of [Ashanti] origin.

[Mancala]: https://en.wikipedia.org/wiki/Mancala
[Ashanti]: https://en.wikipedia.org/wiki/Ashanti_Empire

The games in the Mancala family have spread all over the world. They crossed the Sahara with the gold and salt trade to East Africa, where they then crossed to Southern Asia. I recall a friend visiting my house, who spotted a board and told me that she had played the game as a young girl in Malaysia.

One of its charms is its radical simplicity. It is often played with pebbles and its scooped out of the ground or sand. It can be played with cups and marbles, pennies, or even twiddly-winks. In that respect, it reminds me of tic-tac-toe. It can be played almost anywhere, almost any time, by almost everyone.

I think that I first learned to play Oware in Nigeria, because what I recall of the rules closely matches the rules of **[Ayoayo]**, the variation of the game played by the Yoruba people of Nigeria.

[Ayoayo]: https://en.wikipedia.org/wiki/Ayoayo

---

[![Stone at Tolowa Dunes State Park](/assets/images/ayoayo/sand-stone.jpg)](https://www.flickr.com/photos/fenroc/41505068312)

*One of Ayoayo's charms is its radical simplicity. It is often played with pebbles and its scooped out of the ground or sand.*

---

### how to play ayoayo

Ayoayo is played on the most common Oware layout, a board with two rows of six pits. Many boards also provide with a pit on each side of the board for "captured" stones, but this is optional when playing Ayoayo.

The players face each other with the board between them, such that each player has a row of six pits in front of them. These pits "belong" to that player. If extra pits are provided for captured stones, each player takes one for themselves, but the extra pits are not in play. (In some other games in the same family, pits for captured stones are used in play.)

We've mentioned capturing stones several times, and for good reason: The game play consists of capturing stones, and when the game is completed, the player who has captured the most stones, wins.

The rules are simple:

*The game begins with four stones in each of the twelve pits. Thus, the game requires 48 stones. Pebbles, marbles, or even lego pieces can be used to represent the stones. A wooden board is nice, but pits can be scooped out of earth or sand to make a board. This extreme simplicity is part of the game's charm, much as tic-tac-toe's popularity stems in part from the fact that you can play a game with little more than a stick and a piece of flat earth.*

*The players alternate turns, as in many games.*

*On a player's turn, they select one of their pits to "sow." There are some exceptions listed below, but in general if the player has more than one pit with stones, they may select which one to sow. There are many variations on rules for how to sow the stones amongst the Mancala family of games, but in Ayoayo, sowing works like this:*

- The player scoops all of the stones from the starting pit into their hand.
- Moving counter-clockwise, the player drops one stone into each pit.
- On their row, they move from left to right.
- If they reach the end of their row, they move from right to left on their opponent's row (thus "counter-clockwise").
- They always skip the starting pit on their row.
- The sowing pauses when they have sowed the last stone in their hand.

*If the last stone lands in a pit on either side of the board that contains one or more stones, they scoop the stones up (including that last stone), and continue sowing. They continue to skip their original starting pit only, but can sow into any pits that get scooped up in this manner. This is called **relay sowing**.*

*If the last stone lands in an empty pit **on that player's own side**, the player "captures" any stones that are in the pit on the opponent's side of the board from their last pit.*

*If a player has no move on their turn, the game ends, and their opponent captures any remaining stones (which will--of course--be on their side)*.

*If a player is able to make a move that leaves their opponent with one or more moves to make, they must make a move that leaves their opponent with one or more moves to make. If a player has several such moves (as is usually the case), the player may choose which move to make.*

---

[![Natural Mancala Game](/assets/images/ayoayo/pebbles.jpg)](https://www.flickr.com/photos/candiedwomanire/104320826)

*A natural Mancala game.*

---

### a starting point: the board, the stones, and sowing

If we were going to make an Ayoayo program, where would we start?

Let's start with a simple idea: We'll have to represent the state of the game. We could use an array for the twelve pits of the game, with an integer representing the number of stones in that pit. We'll initialize it with four stones in each pit:

```javascript
const gamePits = Array(12).fill(4);
```

---

[![Associating array elements with pits](/assets/images/ayoayo/3.png)](https://www.flickr.com/photos/narasclicks/4654106883/)

*Associating the elements of the array with the pits belonging to the players.*

---

In Ayoayo, a full turn involves *relay sowing* as described above:

> When relay sowing, if the last stone during sowing lands in an occupied hole, all the contents of that hole, including the last sown stone, are immediately re-sown from the hole.

The other kind of sowing, as used in other games from the same family, is just called _sowing_. The sowing stops when the last stone is sown, regardless of whether the last stone lands in an occupied or unoccupied pit.

It's fairly obvious that if we make a function for sowing, we can use that to make a function for relay sowing, so let's start with an ordinary sowing function. We'll make a relay sowing function later.

The first thing we need is a function to scoop up the stones from a pit:

```javascript
function scoop(fromPit) {
  const stonesInHand = gamePits[fromPit];

  gamePits[fromPit] = 0;

  return stonesInHand;
}
```

We'll also need a function to distribute stones. It needs to know which pit to skip, where to start distributing, and how many stones to are in the hand that need to be distributed:

```javascript
function distribute(skipPit, currentPit, stonesInHand) {

  // now what?

}
```

The first thing our `distribute` function needs to do is place a stone from the hand into the current pit. With a wrinkle that if the current pit is the skip pit, move to the next pit:


```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  // And now what?
}
```

What should we do next?

Well, if we don't have any more stones in hand, we're done. We should return the current pit so that other code can do things like work out whether to continue sowing, or determine whether to capture any stones from our opponent:

```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    // what goes here?
  }
}
```

If we still have stones, then what? We need to keep sowing. We *could* rewrite `distribute` to have a loop of so kind, maybe `do { ... } while (...)`. But hang on!

`distribute` is a function that takes a pit to skip, a current pit, and a number of stones in hand. It returns the result of sowing stones. That's what we need to return, with just one alteration: We need distribute starting with the next pit. So let's just do that:

```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    return distribute(skipPit, nextPit(currentPit), stonesInHand);
  }
}
```

With `scoop` and `distribute`, we can write `sow`:

```javascript
function sow(skipPit, fromPit = skipPit) {
  return distribute(skipPit, nextPit(fromPit), scoop(fromPit));
}
```

Let's try it:

```javascript
sow(0)
  //=> 4

gamePits
  //=> [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4]
```

We can test it by hand.

---

![initial position](/assets/images/ayoayo/4.jpg)

---

And after sowing once, it looks like this:

---

![position after sowing from position zero](/assets/images/ayoayo/5.jpg)

---

Now, there were five stones in the last pit (pit `4`). If there are two or more stones in the last pit, it wasn't empty before we sowed the last stone into it. So when relay sowing, we'd sow again, only this time we'll tell our function start at pit `4`, where we left off last time:

```javascript
sow(0, 4)
  //=> 9
```

Five stones in the last pit (`9`), Let's do it again:

```javascript
sow(0, 9)
  //=> 3
```

Six stones in pit `3`! Again:

```javascript
sow(0, 3)
  //=> 9

pits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

Aha, just one stone in pit `9`, we're done. Let's try it by hand, remembering to skip pit `0`, and compare:

---

![position after relay sowing from position zero](/assets/images/ayoayo/6.jpg)

---

Let's look at our accumulated code all together:

```javascript
function scoop(fromPit) {
  const stonesInHand = gamePits[fromPit];

  gamePits[fromPit] = 0;

  return stonesInHand;
}

function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    return distribute(skipPit, nextPit(currentPit), stonesInHand);
  }
}

function sow(skipPit, fromPit = skipPit) {
  return distribute(skipPit, nextPit(fromPit), scoop(fromPit));
}

let gamePits = Array(12).fill(4);

sow(0)
  //=> 4
sow(0, 4)
  //=> 9
sow(0, 9)
  //=> 3
sow(0, 3)
  //=> 9

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We're off to a reasonable start. And as it happens, the recursive solution is actually straightforward to explain and to implement.

---

[![Toghiz Qumalaq](/assets/images/ayoayo/toghiz-qumalaq.jpg)](https://www.flickr.com/photos/upyernoz/5662602383)

*[Toguz korgool](https://en.wikipedia.org/wiki/Toguz_korgol) (Kyrgyz: тогуз коргоол - "nine sheep droppings") or toguz kumalak/toghiz qumalaq (Kazakh: тоғыз құмалақ), is a two-player game in the mancala family that is played in Central Asia.*

---

### a most practical digression

Let's look at our calls to `sow` again:

```javascript
sow(0)
sow(0, 4)
sow(0, 9)
sow(0, 3)
 ```

Shall we try it again?

```javascript
sow(0)
  //=> undefined
```

D'oh! We forgot to reset the board. Our `sow` function relies upon a mutable value from outside of its body--`gamePits`--and indeed it mutates that value by changing the contents of the array. Thus, when you invoke `sow`, you don't know what you're going to get unless you already know the state of `gamePits`.

We say that `sow` is *coupled* to `gamePits`. In order to test `sow`, we have to first carefully set up `gamePits` to align with our expectations. We see this kind of thing when writing production code for large systems: Many tests do more work setting up and tearing down all of the required initial conditions than they do actually testing functions and methods.

So coupling a function to a mutable value requires us to keep track of that value in order to understand what `sow` will or won't do. That adds some complexity to understanding our system. And this coupling is *transitive*: Not only is `sow` coupled to `gamePits`, any other function we write that is coupled to `gamePits`, becomes coupled to `sow`. Running `sow` changes the behaviour of any  function coupled to `gamePits` because `sow` mutates `gamePits`.

In fact, `sow` is coupled to itself! Even if we remember to correctly initialize `gamePits` before running `sow`, the order in which we invoke `sow` affects the results.

Having a single variable, `gamePits`, describing the state of the game in progress does feel intuitively sound. There is only one board in the game, and when we sow stones, we change it. So why shouldn't we "model the real world accurately?"

That question is easy to answer: I used to own a typewriter. It had no "undo." It had no "copy" or "paste," those functions were accomplished by making copies of pages and laboriously cutting sections of text out with an x-acto blade and gluing them onto other pieces of paper. The text editor I am using now is superior to my typewriter precisely because it does not insist on modelling the real world accurately.

Modelling the real world is a tool for exploring ideas in software and for helping others read our software: What is familiar, subjectively feels "intuitive."[^raskin] But when the modelling interferes with our ability to understand our software's behaviour, we should relax our desire to make everything about modelling. What we seek is maximum understandability and maximum flexibility, not maximum fidelity.

[^raskin]: [Intuitive Equals Familiar], Jef Raskin, 1994

[Intuitive Equals Familiar]: https://www.asktog.com/papers/raskinintuit.html

So how can we "decouple" or code from itself and each other?

---

[![Two coupled high-speed trains ETR 610 of SBB on the Gotthard line](/assets/images/ayoayo/couplings.jpg)](https://www.flickr.com/photos/kecko/33884931711)

*Picture of a train **coupling**.*

---

### decoupling code from shared mutable values

The easiest thing is the obvious thing: If a function shares mutable values with another function (or itself!), and we wish to remove the coupling caused by changes to the shared mutable values, we rewrite the functions to get rid of the shared mutable values. This is an easy refactoring:[^Dependency-Injection]

- We take all of the references to shared mutable values that functions must read, and replace them with parameters.
- We take all of the references to shared mutable values that functions must write, and replace them with creating *copies* of the shared mutable values. We then return those copies along with any other return values the functions already have.

[^Dependency-Injection]: In "How to Deal With Dirty Side Effects in Your Pure Functional Javascript," James Sinclair calls this [Dependency Injection].

[Dependency Injection]: https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/ "How to Deal With Dirty Side Effects in Your Pure Functional Javascript"

So our code becomes:

```javascript
function scoop(before, fromPit) {
  const after = before.slice(0);
  const stonesInHand = after[fromPit];

  after[fromPit] = 0;

  return [after, stonesInHand];
}

function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(before, skipPit, currentPit, stonesInHand) {
  const after = before.slice(0);

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++after[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return [after, currentPit];
  } else if (stonesInHand > 0) {
    return distribute(after, skipPit, nextPit(currentPit), stonesInHand);
  }
}

function sow(before, skipPit, fromPit = skipPit) {
  const [after, pitsInHand] = scoop(before, fromPit);

  return distribute(after, skipPit, nextPit(fromPit), pitsInHand);
}
```

And we use it like this:

```javascript
let gamePits = Array(12).fill(4);

sow(gamePits, 0)
  //=> [
         [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4],
         4
       ]
```

If we want to update the game mutable values, we can choose to do that:

```javascript
let gamePits = Array(12).fill(4);
let lastPit;

[gamePits, lastPit] = sow(gamePits, 0);

gamePits
  //=> [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4]
```

Well. At first sight, there seem to be more moving parts with this approach.[^well] But in truth, they were always there, it's just that we "lifted" them into the interface of the `scoop`, `distribute`, and `sow` functions where we can see them. And now, we can test any arbitrary invocation without having to remember to set things up in advance.

[^well]: Well, the "elephant in the room" is the creation and abandonment of copies of arrays. There are several ways to address this issue, but for the moment they are not germane to the direction of the essay. But we may return to it later.

For example, here's the second call we made:

```javascript
sow([0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4], 0, 4)
  //=> [
         [0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 4, 4],
         9
       ]
```

Checks out, and so do the third and fourth calls we made:

```javascript
sow([0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 4, 4], 0, 9)
  //=> [
         [0, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5],
         3
       ]

sow([0, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5], 0, 3)
  //=> [
         [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5],
         9
       ]
```

We get to the same place, but we can run our "tests" in any order and don't have to do any set up in advance.

The lesson learned is that decoupling functions from mutable mutable values makes them easier to understand and test. And if we want to model the "real world" by having a value representing the current game mutable values, we can still do that:

```javascript
let gamePits = Array(12).fill(4);

let initialChoice = 0;
let lastPit;

[gamePits, lastPit] = sow(gamePits, initialChoice);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);

gamePits[lastPit]
  //=> 1

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We're now ready to automate the "relay sowing."

---

<iframe width="620" height="349" src="https://www.youtube.com/embed/A4v1WkzY3gA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

*[Relayer] is an album by Prog Rock progenitors Yes. It is notable for being the first album they recorded without Rick Wakeman, who wanted to break from the emphasis on long-form compositions.*

[Relayer]: https://en.wikipedia.org/wiki/Relayer

---

### relay sowing

We have implemented "relay sowing" by hand above. It's time to write a `relaySow` function. We could modify `sow`, but accreting new functionality on top of old is a recipe for bloat.

How do we start `relaySow`? Well, with `sow`:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  // what happens next?
}
```

Well, what **does** happen next? I think we know the answer: We need to check and see whether the number of stones in the last pit is one or not:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  if (after[lastPit] === 1) {
    return [after, lastPit];
  } else {
    // now what?
  }
}
```

"Now what," indeed. Now what? We can't just call `sow` again and return the result, that won't work if we end up needing to sow a third time. We'd need all sorts of nested `if` statements. Yecch.

We *could* rewrite `relaySow` to have a loop of so kind, maybe `do { ... } while (...)`. But hang on! With `distribute`, we recursively called `distribute` when there was more work to be done. Let's use the same pattern:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  if (after[lastPit] === 1) {
    return [after, lastPit];
  } else {
    return relaySow(after, skipPit, lastPit);
  }
}

let gamePits = Array(12).fill(4);
let lastPit;

[gamePits, lastPit] = relaySow(gamePits, 0);

lastPit
  //=> 9

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We have relay sowing working. What else do we need to model a player's turn?

---

[![Game of Go at Club Saarto](/assets/images/ayoayo/saarto.jpg)](https://www.flickr.com/photos/jlarnos/37641991971)

*Go is a completely different game from the Mancala family, but they share the notion of capturing stones.*

---

### capturing stones

Relay sowing ends when the last stone is placed in an empty hole. In Ayoayo, if that empty hole is on the player's side, they capture all of the stones in the corresponding hole on the opponent's side:

```javascript
function capturedStones(before, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const after = before.slice(0);
    const stones = after[pitOnOpponentsSide];

    after[pitOnOpponentsSide] = 0;

    return [after, stones];
  } else {
    return [before, 0];
  }
}
```

We will try it:

```javascript
const gameStart = Array(12).fill(4);
const startPit = 0;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, captured] = capturedStones(afterSowing, startPit, endPit);

afterTurn
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]

endPit
  //=> 9

captured
  //=> 0
```

No stones were captured, because the last pit was pit nine on the other side. How can we get a test case that captures stones? Should we try the numbers at random or in sequence? We don't have to. The starting position of the board is symmetrical under rotation. So if move `0` ends up with the board in a certain layout after sowing, and ending on pit `9`, it follows that choosing `1` should lead to exactly the same layout, but rotated one pit counter-clockwise, and the last pit will be `10`.

Well this makes things easy. If the player chooses to start with `3`, the last pit should be `0`, on the player's own side:

```javascript
const gameStart = Array(12).fill(4);
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, captured] = capturedStones(afterSowing, startPit, endPit);

afterSowing
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 6]

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

endPit
  //=> 0

captured
  //=> 6
```

---

![state of the board after the first player chooses pit three](/assets/images/ayoayo/7.jpg)

*The state of the board after the first player chooses pit three.*

---

If we want to update the game state, we'll need a notion of a "score," and we can change `capturedStones` into `handleCapture`:

```javascript
function handleCaptures(beforeBoard, beforeScore, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const afterBoard = beforeBoard.slice(0);
    const playerNumber = startPit > 5 ? 1 : 0;
    const afterScore = Object.assign(
      beforeScore,
      { [playerNumber]: beforeScore[playerNumber] + beforeBoard[pitOnOpponentsSide] }
    );
    afterBoard[pitOnOpponentsSide] = 0;

    return [afterBoard, afterScore];
  } else {
    return [beforeBoard, beforeScore];
  }
}

const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, scoreAfter] = handleCaptures(afterSowing, scoreStart, startPit, endPit);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

scoreAfter
  //=> {0: 6, 1: 0}
```

Finally, we can assemble sowing and capturing together:

```javascript
function sowAndCapture(beforeBoard, beforeScore, startPit) {
  const [afterSowing, endPit] = relaySow(beforeBoard, startPit);
  const [afterTurn, scoreAfter] = handleCaptures(afterSowing, beforeScore, startPit, endPit);

  return [afterTurn, scoreAfter];
}

const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterTurn, scoreAfter] = sowAndCapture(gameStart, scoreStart, startPit);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

scoreAfter
  //=> {0: 6, 1: 0}
```

We now have *almost* everything we need to referee a game between two players. Not enough to write a program to play on its own, but we almost have enough to get going on—for example—a web site that would allow players to play each other online. So what are we missing?

Two things: Determining when the game is over, and determining which moves are permissible. The former depends upon the latter, so our next step is to determine which moves a player is allowed to make.

---

[![no entry?](/assets/images/ayoayo/no-entry.jpg)](https://www.flickr.com/photos/lee-yoshi/15368560025)

*In Ayoayo, some moves are permitted, and some are prohibited.*

---

### permissible moves

In working out which moves are permissible, we need think of only three rules. First, a player can only choose one of the six pits on their side. We'll call this the set of potential moves. Second, a player can only choose a potential move if that pit has one or more stones in it. We'll call the set of potential moves that also have stones to be the set of possible moves:

```javascript
function potentialMoves(player) {
  if (player === 0) {
    return [0, 1, 2, 3, 4, 5];
  } else {
    return [6, 7, 8, 9, 10, 11];
  }
}
```

Now what about filtering the potential moves down to those that are possible?

```javascript
function possible(pits, pit) {
  return pits[pit] > 0;
}

function possibleMoves(pits, moves) {
  if (moves.length === 0) {
    return moves
  } else {
    const [first, ...rest] = moves;

    if (possible(pits, first)) {
      return [first].concat(possibleMoves(pits, rest));
    } else {
      return possibleMoves(pits, rest);
    }
  }
}
```

We can see this in action from our previous work:

```javascript
const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, scoreAfter] = handleCaptures(afterSowing, scoreStart, startPit, endPit);
const potentialMovesForPlayerOne = potentialMoves(1);
const possibleMovesForPlayerOne = possibleMoves(afterTurn, potentialMovesForPlayerOne);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

possibleMovesForPlayerOne
  //=> [7, 8, 9, 10]
```

We've covered rules one and two. Before we move on to the third rule, our implementation of `possibleMoves` deserves some commentary.

---

[![Symbolics "old style" keyboard](/assets/images/ayoayo/symbolics.jpg)](https://www.flickr.com/photos/mrbill/5336327890)

*[Symbolics, Inc.][Symbolics] was a computer manufacturer headquartered in Cambridge, Massachusetts, and later in Concord, Massachusetts, with manufacturing facilities in Chatsworth, California. Symbolics designed and manufactured a line of Lisp machines, single-user computers optimized to run the Lisp programming language.*

[Symbolics]: https://en.wikipedia.org/wiki/Symbolics

---

###  wherein we travel back in time to the dawn of functional programming

A very long time ago, many of the functional tools we take for granted today--like `map` and `filter` functions--were first being explored with the [Lisp] programming language.

[Lisp]: https://en.wikipedia.org/wiki/Lisp_(programming_language)

Lisp grew to have a rich set of high-performance datatypes, but in its earliest incarnations, most of its data was built around something called a [cons] cell. A cons cell was a place in memory big enough to hold two pointers. The underlying hardware was such that operations on cons cells were very fast.

[cons]: https://en.wikipedia.org/wiki/cons

Cons cells had two parts, an _address register_, and a _decrement register_. You created a cons cell by _cons-ing_ two values together. You could access the individual parts with two functions, `car` ("contents of address register"), and `cdr` ("contents of decrement register").

This is all very relevant to the style of programming where lists are broken into a "first" and "rest," because lists in those days were represented as singly linked lists of cons cells. A list was stored as a reference to the first cons cell. The `car` of that cell was a pointer to the first item in the list, and the `cdr` was a pointer to the next cons cell in the list, which was identically configured.

The last cons cell in the list would have `null` for its `cdr`, and `null` was a shorthand for the empty list.

Thus, it was ridiculously fast to separate a list into the first and rest. And it was equally fast to compose a list by cons-ing a new element with an existing list. And therefore, plenty of textbooks used ot describe recursive algorithms just like the one in `possibleMoves`.

They were mathematically elegant **and** fast. But today, we are working with arrays. And when we write something like `first, ...rest] = moves`, the system makes a copy of the rest of the array. And later, when we write something like `[first].concat(possibleMoves(pits, rest))`, the system again makes copies of the arrays.

We're only working with six elements at a time, so we can afford to chuckle at the performance implications. But the important takeaway here is not that those old algorithms were slow. They weren't. The important takeaway is that it is important to match algorithms to data structures, because what is fast with one data structure may be slow with another.

And most importantly, if there are two ways to do something, and one is more elegant, it may be possible to find a data structure that makes the elegant approach fast. We should never rush to trade elegance for performance without further investigation.

And now back to rule three.

---

[![three buffalo](/assets/images/ayoayo/buffalo.jpg)](https://www.flickr.com/photos/lorenkerns/10238986875)

*Three buffalo. Aren't they magnificent?*

---

### implementing the third rule, with a digression into encapsulation

The third rule for whether a move is permissible is far more interesting than the first two:

> If a player ends his or her turn with no seeds left in his or her row, the opponent must (if it is possible) choose his move in such a way to bring one or more seeds into the other's row. This scheme is found in many Mancala games, and sometimes referred to as "feeding" the opponent (i.e., save the opponent from starving).

As expressed, this rule is not equivalent to the simpler, "If you can make a move that leaves your opponent with a move, you must." This rule only applies to the situation where the opponent's play leaves them with no stones/seeds on their row. Fine, let's code that.

The first and obvious thing to take into account is that this has no effect if the opponent has one or more pits with stones in them. For that, we'll need a function to determine whether a player has at least one possible move. We'll use the `[first, ...rest]` recursive pattern from above.

After all, a player has at least one possible move out of some set of moves if the first move is possible or if there is at least one possible move out of the remaining moves, right? For the sake of conversation, we'll introduce a slightly new pattern: We'll invoke a named function expression, recursively:

```javascript
function atLeastOnePossibleMove(pits, player) {
  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return (function atLeastOne(pits, moves) {
    if (moves.length === 0) {
      return false;
    } else {
      const [first, ...rest] = moves;

      return pits[first] > 0 || atLeastOne(pits, rest);
    }
  })(pits, row);
}
```

Before we move on to write a `permissibleFilter`, let's look at this pattern. We're combining an [immediately invoked function expression] (or "IIFE") with a [named function expression] (a/k/a "NFE"). This allows us to create what amounts to a recursive expression *inside another function*.

[immediately invoked function expression]: https://en.wikipedia.org/wiki/Immediately-invoked_function_expression
[named function expression]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function

It could also have been written like this:

```javascript
function atLeastOnePossibleMove(pits, player) {
  function atLeastOne(pits, moves) {
    if (moves.length === 0) {
      return false;
    } else {
      const [first, ...rest] = moves;

      return pits[first] > 0 || atLeastOne(pits, rest);
    }
  }

  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return atLeastOne(pits, row);
}
```

Or even like this, a pattern we'll call "flat functions," because they're all in one flat space:

```javascript
function atLeastOne(pits, moves) {
  if (moves.length === 0) {
    return false;
  } else {
    const [first, ...rest] = moves;

    return pits[first] > 0 || atLeastOne(pits, rest);
  }
}

function atLeastOnePossibleMove(pits, player) {
  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return atLeastOne(pits, row);
}
```

Putting `atLeastOne` inside `atLeastOnePossibleMove` serves to "hide" it from other code. Given that we own a text editor and have a "commit bit," such hiding serves as much to communicate our thought that `atLeastOne` is only intended to be used by `atLeastOnePossibleMove`. Encapsulating code like this discourages excessive interdependencies, which reduces coupling.

Using an IIFE is mostly a matter of taste. It's a longstanding JavaScript and Lisp idiom. Using a NFE inside an IIFE to enable recursion is the idiomatic way to create a recursive IIFE, if that's what we want.[^Mockingbird]

[^Mockingbird]: We could also have used a recursive combinator like the [Mockingbird], but that is outside of the scope of this essay.
[Mockingbird]: http://raganwald.com/2018/08/30/to-grok-a-mockingbird.html "To Grok a Mockingbird"

In a high-performance application, there are some issues around whether a nested function is created anew with every invocation. It's certainly the case that if a nested function "closes over" variables from its parent, a new environment must be created on every invocation of its parent.

So if we write this code, it will absolutely consume a little more memory with every invocation of `atLeastOnePossibleMove`:

```javascript
function atLeastOnePossibleMove(pits, player) {
  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return (function atLeastOne(moves) {
    if (moves.length === 0) {
      return false;
    } else {
      const [first, ...rest] = moves;

      return pits[first] > 0 || atLeastOne(rest);
    }
  })(pits, row);
}
```

In this version, `atLeastOne` takes advantage of the enclosed environment to reference the `pits` variable from `atLeastOnePossibleMove`'s scope.

In our original version, it didn't, and thus it is _possible_ for the environment to optimize the original version by hoisting `atLeastOne` outside of `atLeastOnePossibleMove`, in effect rewriting our code in "flat functions" form behind the scenes.[^hoisting]

[^hoisting]: In JavaScript, the term [hoisting][hoistingjs] nearly always refers to the specified behaviour of using function declarations and `var` declarations inside of blocks within a function. They are "hoisted" to the top level of the function. But "hoisting" in programming language implementations also refers to an optimization technique that consists of mechanically discovering when functions could be hoisted outside of their enclosing functions, and then hoisting them invisibly. In some language implementations, functions can be hoisted even when they read (but not write) enclosing variables by rewriting them to use dependency injection, much as we've discussed here.

[hoistingjs]: https://developer.mozilla.org/en-US/docs/Glossary/Hoisting

But when we take advantage of scope, the environment cannot rewrite our code. Does that matter? If performance is not a bottleneck, we should always prefer the code that communicates our intent.

But let's move on and get started on `permissibleFilter`:

```javascript
function permissibleFilter(pits, moves) {
  // the degenerate case
  if (moves.length === 0) {
    return moves;
  }

  const firstMove = moves[1];
  const otherPlayer = firstMove > 5 ? 1 : 0;
  const otherPlayerHasStones =
    atLeastOnePossibleMove(pits, otherPlayer);

  if (otherPlayerHasStones) {
    return moves;
  }

  // Ok, what do we do here?
}
```

We've handled the obvious: If the other player has stones on their side of the board, any of the supplied moves are permissible. But if they don't have any stones on their side of the board, we have to figure out if any of the moves will "feed" them by placing at least one stone on their side of the board.

Sounds like we need another filter function. Here we go:

```javascript
function movesThatFeedTheOtherPlayer(before, moves) {
  // the degenerate case
  if (moves.length === 0) {
    return moves;
  }

  const [first, ...rest] = moves;
  const irrelevantScore = { 0: 0, 1: 0 };
  const [after] = sowAndCapture(before, irrelevantScore, first);
  const otherPlayer = first > 5 ? 0 : 1;
  const otherPlayerHasStonesAfter =
    atLeastOnePossibleMove(after, otherPlayer);

  if (otherPlayerHasStonesAfter) {
    return [first].concat(movesThatFeedTheOtherPlayer(before, rest));
  } else {
    return movesThatFeedTheOtherPlayer(before, rest);
  }
}

const lateGameBoard = [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0];
const potentialMovesForPlayerZero = potentialMoves(0);
const possibleMovesForPlayerZero = possibleMoves(lateGameBoard, potentialMovesForPlayerZero);
const movesThatFeedPlayerOne = movesThatFeedTheOtherPlayer(lateGameBoard, possibleMovesForPlayerZero);

movesThatFeedPlayerOne
  //=> [2]
```

And now we can finish `permissibleFilter`, then put it all together into `permissibleMoves`:

```javascript
function permissibleFilter(pits, moves) {
  // the degenerate case
  if (moves.length === 0) {
    return moves;
  }

  const firstMove = moves[1];
  const otherPlayer = firstMove > 5 ? 0 : 1;
  const otherPlayerHasStones =
    atLeastOnePossibleMove(pits, otherPlayer);

  if (otherPlayerHasStones) {
    return moves;
  } else {
    const permissibleMoves = movesThatFeedTheOtherPlayer(pits, moves);

    if (permissibleMoves.length > 0) {
      return permissibleMoves;
    } else {
      // slightly irrelevant, as the gamne is about to end
      // no matter which move is chosen
      return moves;
    }
  }
}

function permissibleMoves(before, player) {
  const potentialMovesForPlayer = potentialMoves(player);
  const possibleMovesForPlayer = possibleMoves(lateGameBoard, potentialMovesForPlayer);
  const permissibleMovesForPlayer = permissibleFilter(lateGameBoard, possibleMovesForPlayer);

  return permissibleMovesForPlayer;
}

const lateGameBoard = [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0];

permissibleMoves(lateGameBoard, 0)
  //=> [2]
```

Whew! We're almost done writing the things we would need to handle game mechanics if we were writing an Ayoayo game. The final thing is the end condition. If a player has no stones in their row at the beginning of their turn, their opponent collects all of the stones left on the board, and the game ends.

Let's implement that.

---

[![A whole new view of the Crab Nebula](/assets/images/ayoayo/crab.jpg)](https://www.flickr.com/photos/hubble_esa/22823588348)

*Everything ends, not just games, but even stars: In 1054 AD, during the Song dynasty, Chinese astronomers spotted a bright new star in the night sky. This newcomer turned out to be a violent explosion within the Milky Way, caused by the spectacular death of a star some 1600 light-years away. This explosion created one of the most well-studied and beautiful objects in the night sky--the Crab Nebula. ([More information][crabinfo].)*

[crabinfo]: www.spacetelescope.org/images/potw1644a/

---

### ending the game

We said above that "If a player has no stones in their row at the beginning of their turn, their opponent collects all of the stones left on the board, and the game ends." That is equivalent to saying that "If, after making a permissible move, your opponent's row is empty, you capture all of the stones in your row, and then the game ends."

Put that way, we don't need a brand new function, we can update `handleCaptures`. That function is already big enough and has one clear responsibility, handling the ordinary kind of capture. So let's extract that and make it a helper, then write a new function to handle captures after completing a turn:

```javascript
function handleCapturesInTurn(beforeBoard, beforeScore, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const afterBoard = beforeBoard.slice(0);
    const playerNumber = startPit > 5 ? 1 : 0;
    const afterScore = Object.assign(
      beforeScore,
      { [playerNumber]: beforeScore[playerNumber] + beforeBoard[pitOnOpponentsSide] }
    );
    afterBoard[pitOnOpponentsSide] = 0;

    return [afterBoard, afterScore];
  } else {
    return [beforeBoard, beforeScore];
  }
}

function handleGameEnd(beforeBoard, beforeScore, playerWhoJustMoved) {
  // Write function here!
}

function handleCaptures(beforeBoard, beforeScore, startPit, endPit) {
  const [afterCapturesInTurn, afterScoreInTurn] =
    handleCapturesInTurn(beforeBoard, beforeScore, startPit, endPit);
  const playerWhoJustMoved = startPit > 5 ? 1 : 0;
  const [afterTurn, afterScore] = handleGameEnd(afterCapturesInTurn, afterScoreInTurn, playerWhoJustMoved);
  const isOver = (afterScore[0] + afterScore[1]) === 48;

  return [afterTurn, afterScore, isOver];
}

function sowAndCapture(beforePits, beforeScore, startPit) {
  const [afterSowing, endPit] = relaySow(beforePits, startPit);
  const [afterTurn, scoreAfter, isOver] = handleCaptures(afterSowing, beforeScore, startPit, endPit);

  return [afterTurn, scoreAfter, isOver];
}
```

And now let's write `handleGameEnd`. For starters, we check whether the other player has moves, if they do, there is no effect:

```javascript
function handleGameEnd(beforeBoard, beforeScore, playerWhoJustMoved) {
  const otherPlayerNumber = 1 - playerWhoJustMoved;
  const otherPlayerHasMoves = atLeastOnePossibleMove(beforeBoard, otherPlayer);

  if (otherPlayerHasMoves) {
    return [beforeBoard, beforeScore];
  } else {
    // Capture everything else!
  }
}
```

If they don't, we capture every stone on the player's side. We can gratuitously use our IIFE/NFE recursion pattern again, with a twist:

```javascript
function handleGameEnd(beforeBoard, beforeScore, playerWhoJustMoved) {
  console.log({beforeBoard, beforeScore, playerWhoJustMoved})
  const otherPlayer = 1 - playerWhoJustMoved;
  const otherPlayerHasMoves = atLeastOnePossibleMove(beforeBoard, otherPlayer);

  if (otherPlayerHasMoves) {
    return [beforeBoard, beforeScore];
  } else {
    const playerPits =
      playerWhoJustMoved === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

    const stonesRemaining = (function countStones(board, pits, runningTotal = 0) {
      if (pits.length === 0) {
        return runningTotal;
      } else {
      	const [first, ...rest] = pits;

      	return countStones(board, rest, runningTotal + board[first]);
      }
    })(beforeBoard, playerPits);

    const playerWhoJustMovedScore = beforeScore[playerWhoJustMoved] + stonesRemaining;

    const finalScore = {
      [playerWhoJustMoved]: playerWhoJustMovedScore,
      [otherPlayer]: beforeScore[otherPlayer]
    };

    return [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      finalScore
    ];
  }
}
```

And we can do an "integration test," running our code from end to end:

```javascript
const lateGameBoard = [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0];
const lateGameScore = { 0: 40, 1: 5 };

let [afterTurn, afterScore, isOver] = sowAndCapture(lateGameBoard, lateGameScore, 2);

afterTurn
  //=> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

afterScore
  //=> { 0: 43, 1: 5 }

isOver
  //=> true

const notOverBoard = [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0];
const notOverScore = { 0: 39, 1: 5 }

[afterTurn, afterScore, isOver] = sowAndCapture(notOverScore, lateGameScore, 2);

afterTurn
  //=> [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]

afterScore
  //=> { 0: 39, 1: 5 }

isOver
  //=> false
```

Success! Anything else?

---

[![Stones](/assets/images/ayoayo/stones.jpg)](https://www.flickr.com/photos/sjdunphy/1311812466)


---

### how to determine the winner

If the game is over, the winner is the player who has captured the most stones. Having grown up with basic arithmetic, our first impulse is perhaps to compare the magnitude of each player's captured stones, or perhaps to perform a subtraction and determine whether the result is negative, zero, or positive.

But as noted earlier, one of the charms of Ayoayo is its simplicity. Toddlers who cannot do sums can--and are--taught to play the game and determine a winner. And the way they do it has some deep implications that can take the curious reader far, infinitely far.

Let's imagine we do not know how to count the stones in the sense of converting a pile of stones into a number. And if we did, we wouldn't know how to compare two numbers. (This is consistent with our code above, we use numbers from `0` to `11` to represent pits, and we sometimes compare numbers to `5` to determine which side of the board a pit is on, but those things are conveniences for the computer's representation.)

The actual steps we've performed so can all be performed by someone who knows nothing more than whether a collection of stones is empty or not, and how to remove stones from the hand one at a time.

Given this knowledge, a winner can be determined by having both players pick up their captured stones, then simultaneously remove one stone from their hand at a time. If one player still has stones in their hand when the other runs out, the player with stones has won. If both players run out simultaneously, the game is a tie.

That's simple, and exactly how [Georg Cantor] set about proving that the set of real numbers is more numerous than the set of natural numbers. Here it is, a function that returns the set of all players who won the game:[^zoolander]

[Georg Cantor]: https://en.wikipedia.org/wiki/Georg_Cantor

[^zoolander]: They use *this exact method* to determine whether the number of visitors to Derek Zoolander's Center For Kids Who Can't Read Good is less than the maximum allowed by fire regulations.

```javascript
function whoWonForPeopleWhoCantCountGood (score) {
  return (function oneAtATime (zero, one) {
    if (zero === 0 && one === 0) {
      return [];
    } else if (zero === 0) {
      return [1];
    } else if (one === 0) {
      return [0];
    } else {
      return oneAtATime(zero - 1, one - 1);
    }
  })(score[0], score[1]);
}
```

I was taught a variation on this simple procedure, one that is easier for small children to carry out as it does not rely on simultaneously doing anything. But at it's core, it's the same algorithm.

---

![We have a winner!](/assets/images/ayoayo/winner.jpg)

*The player owning the bottom rows has filled their pits, with five stones left over. The player owning the top row has fallen five stones short. We have a winner, and we're almost ready to start the revenge match.*

---

Let's imagine we're learning to play. We'll start by learning the number _four_. That's easy, almost all of us have four fingers and hopefully four limbs. You can teach someone what four stones are, by saying, "put your fingers on the table/ground, and place a stone next to each one. That's four."

We now take our captured stones, four at a time, and attempt to fill the pits on our side of the board:

- If we fall short, we have lost.
- If we fill our pits exactly, the game is a tie.
- If we have stones left over, we have won.

When both players do this simultaneously, they are determining the winner, _and_ setting the board up for the next game. How elegant! We won't implement that today, but it should be fairly obvious that we can use techniques like the one we used for `whoWonForPeopleWhoCantCountGood` combined with techniques we used for recursively acting on the pits in a player's row to get to the same outcome.

Instead, let's gather ourselves, and look at what all of our functions have in common.

---

[![Wendeltreppe Cafe Glockenspiel by Renate Dodell](/assets/images/ayoayo/glockenspiel.jpg)](https://www.flickr.com/photos/dorena-wm/4862323430)

---

### linear recursion

In programming, a _recursive function_ is a function that invokes itself directly or indirectly. For example, a [merge sort] divides lists into two halves, then calls itself to sort each of the halves before calling `merge` to merge them back together in order.

[merge sort]: https://en.wikipedia.org/wiki/Merge_sor

```javascript
function mergeSort (list) {
  const listLength = list.length;

  if (listLength <= 1) {
    return list;
  } else {
    const cutPoint =  Math.floor(listLength/2);

    const half = list.slice(0, cutPoint);
    const otherHalf = list.slice(cutPoint);

    const sortedHalf = mergeSort(half);
    const sortedOtherHalf = mergeSort(otherHalf);

    return merge(sortedHalf, sortedOtherHalf);
  }
}

function merge (...mutableLists) {
  return recursiveMerge(mutableLists, []);

  function recursiveMerge (mutableLists, mutableSoFar) {
    const listsWithElements = mutableLists.filter(l => l.length > 0);

    if (listsWithElements.length === 0) {
      return mutableSoFar;
    } else if (listsWithElements.length === 1) {
      return mutableSoFar.concat(listsWithElements[0]);
    } else {
      const firsts = listsWithElements.map(l => l[0]);
      const lowest = Math.min(...firsts);
      const indexOfLowest = firsts.indexOf(lowest);
      const listWithLowest = listsWithElements[indexOfLowest];

      listWithLowest.shift();
      mutableSoFar.push(lowest);

      return recursiveMerge(listsWithElements, mutableSoFar)
    }
  }
}

console.log(mergeSort([7, 1, 3, 4, 5, 0, 2, 6]))
  //=> [0, 1, 2, 3, 4, 5, 6, 7]
```

If we draw the call graph for `recursiveMerge`, it's a tree with two branches per node. We say that it's **bi-recursive**.

<div class="mermaid">
  graph TD
    seven1345026["[7, 1, 3, 4, 5, 0, 2, 6]"] --> seven134["[7, 1, 3, 4]"]
    seven134 --> seven1["[7, 1]"]
    seven1 --> seven["[7]"]
    seven1 --> one["[1]"]
    seven134 --> three4["[3, 4]"]
    three4 --> three["[3]"]
    three4 --> four["[4]"]
    seven1345026["[7, 1, 3, 4, 5, 0, 2, 6]"] --> five026["[5, 0, 2, 6]"]
    five026 --> five0["[5, 0]"]
    five0 --> five["[5]"]
    five0 --> zero["[0]"]
    five026 --> two6["[2, 6]"]
    two6 --> two["[2]"]
    two6 --> six["[6]"]
</div>

But if we draw the call tree for any one invocation of `recursiveMerge` within `merge`, it's a straight line:

<div class="mermaid">
  graph TD
    a["[[1,3,4,7],[0,2,5,6]], []"] --> b
    b["[[1,3,4,7],[2,5,6]], [0]"]  --> c
    c["[[3,4,7],[2,5,6]], [0,1]"]  --> d
    d["[[3,4,7],[5,6]], [0,1,2]"]  --> e
    e["[[4,7],[5,6]], [0,1,2,3]"]  --> f
    f["[[7],[5,6]], [0,1,2,3,4]"]  --> g
    g["[[7],[6]], [0,1,2,3,4,5]"]  --> h["[[7],[]], [0,1,2,3,4,5,6]"]
</div>

A *linearly recursive function* is a function where each invocation that invokes itself (directly or indirectly) at most once before returning. Therefore, `recursiveMerge` is a linearly recursive function.

Linear recursion is interesting, and here's why...

---

[![Spiral Bridge of Young Stars Between Two Ancient Galaxies](/assets/images/ayoayo/necklace.jpg)](https://www.flickr.com/photos/gsfc/14625888534)

*Linear recursion is interesting, and so is this photograph showing a spiral bridge of young stars between two ancient galaxies.*

*At the center of the bull's-eye of blue, gravitationally lensed filaments lies a pair of elliptical galaxies that are also exhibiting some interesting features. A 100,000-light-year-long structure that looks like a string of pearls twisted into a corkscrew shape winds around the cores of the two massive galaxies. The "pearls" are superclusters of blazing, blue-white, newly born stars. These super star clusters are evenly spaced along the chain at separations of 3,000 light-years from one another.*

---

### why linear recursion is interesting

Linear recursion is particularly interesting because it is computationally equivalent to iteration. Any function that is linearly recursive, can be rewritten as a function that iterates but is not recursive. The converse is also true: Any piece of code that iterates, can be rewritten as an invocation of a linearly recursive function that does not iterate.

There are important reasons why this equivalence matters to fundamental computer science theory: It shows that if we have functions and function invocation, we don't need to add iteration to prove things about computability. But that isn't what we're going to look at here.

Consider a hypothetical `for` loop inside a function:

```javascript
function doSomethingOrOther (collection) {
  let someVar = somethingOrOther();

  // something happens before the loop

  // frobbish the collection:
  for (const element of collection) {
    // something happens inside the loop to
    // frobbish the collection, element by element
  }

  // something happens after the loop
}
```

What kinds of things can happen inside the loop to "frobbish the collection?" Almost anything can happen inside the loop! Code can `continue`, jumping to the  next iteration. Code can `break` from the loop, jumping straight to `// something happens after the loop`. Code can read variables from outside the loop, and also write to those variables.

Code inside loops can be very tightly coupled to the code outside of the loop. That's kind of the whole point, code inside a loop is rarely thought of as being "separate" from the rest of the code in a function, so why shouldn't it be tightly coupled with that code?

We've seen a lot of code so far, so let's continue with this hypothetical and completely code-free example. Let's imagine we refactor the code to extract the loop into a `frobbish` function:

```javascript
function frobbish (collection, someVar) {
  // something happens inside the function to
  // frobbish the collection, element by element
};

function doSomethingOrOther (collection) {
  let someVar = somethingOrOther();

  // something happens before the loop

  // frobbish the collection:
  const frobbishedCollection =
    frobbish(collection, someVar);

  // something happens after the loop
}
```

We get an immediate win, and I don't mean that our function is shorter: When we lose the linear flow of a function, it's harder to read. We have to get something in exchange, and what we get is actually quite powerful: By extracting the function, it is now clear what our `frobbish` code reads (`collection` and `someVar`), and what it writes (just `collection`).

If We use a fancy editor that has an "extract helper function" refactoring capability, it can extract almost any chunk of code, but if the code was tightly coupled to the rest of the function, we'll get four or five parameters going in, and another four or five coming out.

Whether we do it by hand or not, extracting the function takes what was always there--the dependencies--and makes them explicit. That can encourage us to rewrite the code to eliminate the dependencies, and if we don't, at least it can help us understand what effect that code can have on the rest of the function.

But there's more.

```javascript
function frobbish (collection, someVar) {
  // something happens inside the function to
  // frobbish the collection, element by element
};
```

Code inside the function can become tightly coupled to itself. It can read and write anything it wants. It can set up some variables and modify them inside a loop. In fact, we can move all of the coupling into our extracted function that we wanted to get rid of.

But what if we refactor that function--which was designed to replicate a single piece of iteration--to be linearly recursive?

```javascript
function frobbish (collection, someVar) {
  if (collection.length === 0) {
    // handle the degenerate case
  } else {
    const [first, ...rest] = collection;

    // frobbish the first element, then
    // combine it with frobbish(rest, someVar)
  }
};
```

Recall above where we espoused the value of pure functions as being decoupled from themselves. Doing the same with a linearly recursive function forces us to decouple `frobbish` from itself, making any dependencies explicit, and encouraging us to find ways to eliminate as many dependencies as possible.

In sum, *A tremendous value of expressing code as linear recursion with dependency-free functions rather than as iteration, is that it makes dependencies explicit. That in turn helps us eliminate them.*

Now we _could_ go off on a tangent about how to refactor iteration into linear recursion. But let's sum up what we've gathered from this exercise.

---

[![start/finish line](/assets/images/ayoayo/finish.jpg)](https://www.flickr.com/photos/coltharp/2138482237)

---

### the finish line

We learned that while we *can* refactor functions with dependencies into functions without dependencies (via the "dependency injection" pattern), we can also use what we learned to write them functions without dependencies in the first place. The important thing is not the specifics of the refactoring, but what we are trying to achieve.

It's the same with linear recursion. The important thing is to understand what we're trying to achieve: low coupling.

We don't need to write everything with iteration and then refactor to linear recursion: We can just write it as linear recursion in the first place. When we take a "linear-recursion-first" approach, we naturally end up with code that has high cohesion and low coupling. Linear recursion makes that easy.

Of course, there are real tradeoffs. Constantly making copies of arrays is expensive: We have to select data structures that are less wasteful when we slice them up, or use patterns (like iterators) that allow us to write the equivalent code that doesn't need to do things like copy arrays.

Or we have to learn how to write [tail-recursive][tail-call] functions, and use a language implementation that optimizes our functions for us.

[tail-call]: https://en.wikipedia.org/wiki/Tail_call

Or we have to get it working with linear recursion, and then [refactor it back to iteration][ribti]. This is very interesting, because if we write it with linear recursion, and then refactor it back to iteration, it will retain its uncoupled form. Of course, over time code can accrete and become coupled.

[ribti]: http://raganwald.com/2018/05/20/we-dont-need-no-stinking-recursion.html "Recursion? We don't need no stinking recursion!"

These and other considerations are beyond the scope of this essay. But starting with linear recursion, and then refactoring to iterative code, is an excellent way to ensure that the iteration we do implement is clean and coupling-free.

And in the fullness of time, we will start writing iterative code that is clean and decoupled from the outset, thanks to our familiarity and practice with writing linearly recursive functions. Linear recursion--like dependency-free functions--is a powerful tool for learning what kinds of iterative code is going to be easiest to understand and work with.

---

[![code.close()](/assets/images/ayoayo/code.jpg)](https://www.flickr.com/photos/ruiwen/3260094840)

---

# Appendix: The completed code

<script src="https://gist.github.com/raganwald/d55012c262c02d769054f70f55a1032e.js"></script>


---

# Notes