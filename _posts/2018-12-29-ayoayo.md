---
title: "Ayoayo (unfinished)"
tags: [recursion,allonge]
---

**WARNING:** *This is an unfinished post, temporarily shared for preview and feedback purposes. For example, it lacks a technical introduction: The introduction is usually written after the main ideas are fully fleshed out. Feel free to share this on Twitter, but please do not post it on aggregator sites like Hacker News or Reddit: Those communities prefer to evaluate the finished work.*

---

![Visiting a slave fort in Ghana](/assets/images/ayoayo/fort.jpg)

*I can't be certain, but I believe this is a picture of my sister and I visiting a fort used to house slaves before their transportation (what a bloodless word) to the Americas. If I am correct, this was probably in Ghana near Accra.*

---

### prelude: africa 1968&thinsp;&ndash;&thinsp;1971

In 1968 or thereabouts, [my mother][womansstory] took my sister and I on a trip to West Africa. We returned a year or so later, and lived in Nigeria while she developed software for a brand-new IBM 360 that had been installed at the University of Ibadan. It was a state-of-the-art machine, it had 64K of core memory!

[womansstory]: http://braythwayt.com/posterous/2012/03/29/a-womans-story.html

It is difficult for me to explain the magnitude of the culture shock I experienced. In the 1960s, Toronto was much less visibly multicultural than it is today. I do not recall ever seeing a black police officer, teacher, or newscaster on television. My great-uncle Leonard Braithwaite had become the first black MPP in 1963, but in 1968 he was still more of an exception than a minority, if you follow my drift.

And then I visited Africa. Everyone (well, almost) was black. There was wretched poverty as I'd never imagined. And fantastic wealth. I distinctly recall being amazed to visit the flight deck of our [Air Afrique] flight, and the black pilots let me sit in the co-pilot's chair.

[Air Afrique]: https://en.wikipedia.org/wiki/Air_Afrique

Many institutions in Africa were older than the entire country of Canada. That's something you find in most of the old world, like England or Europe, but it was particularly stunning for me to look at things like the [Great Mosque of Djenné]. The first mosque on that site was built in the late 13th century, three centuries before the first Europeans set permanent foot in Canada.

[Great Mosque of Djenné]: https://en.wikipedia.org/wiki/Great_Mosque_of_Djenné

In 1970, we were even in the crowds for the coronation procession of [Opoku Ware II], 15th Emperor-King of the Ashanti people. The Empire of Ashanti was formed in 1701, two and a half centuries before Canada became a country. I think my brain exploded when we touched down in Africa and continued to erupt the entire time we were there. Everything was literally fantastic.

[Opoku Ware II]: https://en.wikipedia.org/wiki/Opoku_Ware_II

My mother had taken our education "in hand," as they used to say, and I was already aware of various important stories and facts about black people, like Harriet Tubman. I think I had already read some [Anansi] stories from books she had imported by mail. You wouldn't find things like that in a bookstore in those days.

And amongst all those great things, she may have also introduced me to some form of the game [Oware] in Toronto, but my recollection is that I first encountered it in Africa.

[Anansi]: https://en.wikipedia.org/wiki/Anansi
[Oware]: https://en.wikipedia.org/wiki/Oware

---

[![Mancala / Awale / Oware / Ayoayo](/assets/images/ayoayo/board.jpg)](https://www.flickr.com/photos/elpadawan/8479297425/)

*This board can be used to play many different kinds of Oware, including Ayoayo.*

### oware and ayoayo

---

Wikipedia puts it succinctly and well: [Oware] is an abstract strategy game among the [Mancala] family of board games (pit and pebble games) played worldwide with slight variations as to the layout of the game, number of players and strategy of play. Its origin is uncertain, but it is widely believed to be of [Ashanti] origin.

[Mancala]: https://en.wikipedia.org/wiki/Mancala
[Ashanti]: https://en.wikipedia.org/wiki/Ashanti_Empire

The games in the Mancala family have spread all over the world. They crossed the Sahara with the gold and salt trade to East Africa, where they then crossed to Southern Asia. I recall a friend visiting my house, who spotted a board and told me that she had played the game as a young girl in Malaysia.

One of its charms is its radical simplicity. It is often played with pebbles and its scooped out of the ground or sand. It can be played with cups and marbles, pennies, or even twiddly-winks. In that respect, it reminds me of tic-tac-toe. It can be played almost anywhere, almost any time, by almost everyone.

I think that I first learned to play in Nigeria, because what I recall from the rules closely matches the rules of **[Ayoayo]**, the variation of the game played by the Yoruba people of Nigeria.

[Ayoayo]: https://en.wikipedia.org/wiki/Ayoayo

---

[![Stone at Tolowa Dunes State Park](/assets/images/ayoayo/sand-stone.jpg)](https://www.flickr.com/photos/fenroc/41505068312)

*One of Ayoayo's charms is its radical simplicity. It is often played with pebbles and its scooped out of the ground or sand.*

---

### how to play ayoayo

Ayoayo is played on the most common Oware layout, a board with two rows of six pits. Many boards also provide with a pit on each side of the board for "captured" stones, but this is optional when playing Ayoayo.

The players face each other with the board between them, such that each player has a row of six pits in front of them. These pits "belong" to that player. If extra pits are provided for captured stones, each player takes one for themselves, but the extra pits are not in play. (In some other games in the same family, pits for captured stones are used in play.)

We've mentioned capturing stones several times, and for good reason: The game play consists of capturing stones, and when the game is completed, the player who has captured the most stones, wins.

The rules are simple:

*The game begins with four stones in each of the twelve pits. Thus, the game requires 48 stones. Pebbles, marbles, or even lego pieces can be used to represent the stones. A wooden board is nice, but pits can be scooped out of earth or sand to make a board. This extreme simplicity is part of the game's charm, much as tic-tac-toe's popularity stems in part from the fact that you can play a game with little more than a stick and a piece of flat earth.*

*The players alternate turns, as in many games.*

*On a player's turn, they select one of their pits to "sow." There are some exceptions listed below, but in general if the player has more than one pit with stones, they may select which one to sow. There are many variations on rules for how to sow the stones amongst the Mancala family of games, but in Ayoayo, sowing works like this:*

- The player scoops all of the stones from the starting pit into their hand.
- Moving counter-clockwise, the player drops one stone into each pit.
- On their row, they move from left to right.
- If they reach the end of their row, they move from right to left on their opponent's row (thus "counter-clockwise").
- They always skip the starting pit on their row.
- The sowing pauses when they have sowed the last stone in their hand.

*If the last stone lands in a pit on either side of the board that contains one or more stones, they scoop the stones up (including that last stone), and continue sowing. They continue to skip their original starting pit only, but can sow into any pits that get scooped up in this manner. This is called **relay sowing**.*

*If the last stone lands in an empty pit **on that player's own side**, the player "captures" any stones that are in the pit on the opponent's side of the board from their last pit.*

*If a player has no move on their turn, the game ends, and their opponent captures any remaining stones (which will--of course--be on their side)*.

*If a player is able to make a move that leaves their opponent with one or more moves to make, they must make a move that leaves their opponent with one or more moves to make. If a player has several such moves (as is usually the case), the player may choose which move to make.*

---

[![Natural Mancala Game](/assets/images/ayoayo/pebbles.jpg)](https://www.flickr.com/photos/candiedwomanire/104320826)

*A natural Mancala game.*

---

### sowing stones

If we were going to make an Ayoayo program, where would we start?

Let's start with a simple idea: We'll have to represent the state of the game. We could use an array for the twelve pits of the game, with an integer representing the number of stones in that pit. We'll initialize it with four stones in each pit:

```javascript
const gamePits = Array(12).fill(4);
```

---

[![Associating array elements with pits](/assets/images/ayoayo/3.png)](https://www.flickr.com/photos/narasclicks/4654106883/)

*Associating the elements of the array with the pits belonging to the players.*

---

In Ayoayo, a full turn involves *relay sowing* as described above:

> When relay sowing, if the last stone during sowing lands in an occupied hole, all the contents of that hole, including the last sown stone, are immediately re-sown from the hole.

The other kind of sowing, as used in other games from the same family, is just called _sowing_. The sowing stops when the last stone is sown, regardless of whether the last stone lands in an occupied or unoccupied pit.

It's fairly obvious that if we make a function for sowing, we can use that to make a function for relay sowing, so let's start with an ordinary sowing function. We'll make a relay sowing function later.

The first thing we need is a function to scoop up the stones from a pit:

```javascript
function scoop(fromPit) {
  const stonesInHand = gamePits[fromPit];

  gamePits[fromPit] = 0;

  return stonesInHand;
}
```

We'll also need a function to distribute stones. It needs to know which pit to skip, where to start distributing, and how many stones to are in the hand that need to be distributed:

```javascript
function distribute(skipPit, currentPit, stonesInHand) {

  // now what?

}
```

The first thing our `distribute` function needs to do is place a stone from the hand into the current pit. With a wrinkle that if the current pit is the skip pit, move to the next pit:


```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  // And now what?
}
```

What should we do next?

Well, if we don't have any more stones in hand, we're done. We should return the current pit so that other code can do things like work out whether to continue sowing, or determine whether to capture any stones from our opponent:

```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    // what goes here?
  }
}
```

If we still have stones, then what? We need to keep sowing. We *could* rewrite `distribute` to have a loop of so kind, maybe `do { ... } while (...)`. But hang on!

`distribute` is a function that takes a pit to skip, a current pit, and a number of stones in hand. It returns the result of sowing stones. That's what we need to return, with just one alteration: We need distribute starting with the next pit. So let's just do that:

```javascript
function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    return distribute(skipPit, nextPit(currentPit), stonesInHand);
  }
}
```

With `scoop` and `distribute`, we can write `sow`:

```javascript
function sow(skipPit, fromPit = skipPit) {
  return distribute(skipPit, nextPit(fromPit), scoop(fromPit));
}
```

Let's try it:

```javascript
sow(0)
  //=> 4

gamePits
  //=> [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4]
```

We can test it by hand.

---

![initial position](/assets/images/ayoayo/4.jpg)

---

And after sowing once, it looks like this:

---

![position after sowing from position zero](/assets/images/ayoayo/5.jpg)

---

Now, there were five stones in the last pit (pit `4`). If there are two or more stones in the last pit, it wasn't empty before we sowed the last stone into it. So when relay sowing, we'd sow again, only this time we'll tell our function start at pit `4`, where we left off last time:

```javascript
sow(0, 4)
  //=> 9
```

Five stones in the last pit (`9`), Let's do it again:

```javascript
sow(0, 9)
  //=> 3
```

Six stones in pit `3`! Again:

```javascript
sow(0, 3)
  //=> 9

pits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

Aha, just one stone in pit `9`, we're done. Let's try it by hand, remembering to skip pit `0`, and compare:

---

![position after relay sowing from position zero](/assets/images/ayoayo/6.jpg)

---

Let's look at our accumulated code all together:

```javascript
function scoop(fromPit) {
  const stonesInHand = gamePits[fromPit];

  gamePits[fromPit] = 0;

  return stonesInHand;
}

function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(skipPit, currentPit, stonesInHand) {

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++gamePits[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return currentPit;
  } else if (stonesInHand > 0) {
    return distribute(skipPit, nextPit(currentPit), stonesInHand);
  }
}

function sow(skipPit, fromPit = skipPit) {
  return distribute(skipPit, nextPit(fromPit), scoop(fromPit));
}

let gamePits = Array(12).fill(4);

sow(0)
  //=> 4
sow(0, 4)
  //=> 9
sow(0, 9)
  //=> 3
sow(0, 3)
  //=> 9

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We're off to a reasonable start. And as it happens, the recursive solution is actually straightforward to explain and to implement.

---

[![Toghiz Qumalaq](/assets/images/ayoayo/toghiz-qumalaq.jpg)](https://www.flickr.com/photos/upyernoz/5662602383)

*[Toguz korgool](https://en.wikipedia.org/wiki/Toguz_korgol) (Kyrgyz: тогуз коргоол - "nine sheep droppings") or toguz kumalak/toghiz qumalaq (Kazakh: тоғыз құмалақ), is a two-player game in the mancala family that is played in Central Asia.*

---

### a most practical digression

Let's look at our calls to `sow` again:

```javascript
sow(0)
sow(0, 4)
sow(0, 9)
sow(0, 3)
 ```

Shall we try it again?

```javascript
sow(0)
  //=> undefined
```

D'oh! We forgot to reset the board. Our `sow` function relies upon a mutable value from outside of its body--`gamePits`--and indeed it mutates that value by changing the contents of the array. Thus, when you invoke `sow`, you don't know what you're going to get unless you already know the state of `gamePits`.

We say that `sow` is *coupled* to `gamePits`. In order to test `sow`, we have to first carefully set up `gamePits` to align with our expectations. We see this kind of thing when writing production code for large systems: Many tests do more work setting up and tearing down all of the required initial conditions than they do actually testing functions and methods.

So coupling a function to a mutable value requires us to keep track of that value in order to understand what `sow` will or won't do. That adds some complexity to understanding our system. And this coupling is *transitive*: Not only is `sow` coupled to `gamePits`, any other function we write that is coupled to `gamePits`, becomes coupled to `sow`. Running `sow` changes the behaviour of any  function coupled to `gamePits` because `sow` mutates `gamePits`.

In fact, `sow` is coupled to itself! Even if we remember to correctly initialize `gamePits` before running `sow`, the order in which we invoke `sow` affects the results.

Having a single variable, `gamePits`, describing the state of the game in progress does feel intuitively sound. There is only one board in the game, and when we sow stones, we change it. So why shouldn't we "model the real world accurately?"

That question is easy to answer: I used to own a typewriter. It had no "undo." It had no "copy" or "paste," those functions were accomplished by making copies of pages and laboriously cutting sections of text out with an x-acto blade and gluing them onto other pieces of paper. The text editor I am using now is superior to my typewriter precisely because it does not insist on modelling the real world accurately.

Modelling the real world is a tool for exploring ideas in software and for helping others read our software: What is familiar, subjectively feels "intuitive."[^raskin] But when the modelling interferes with our ability to understand our software's behaviour, we should relax our desire to make everything about modelling. What we seek is maximum understandability and maximum flexibility, not maximum fidelity.

[^raskin]: [Intuitive Equals Familiar], Jef Raskin, 1994

[Intuitive Equals Familiar]: https://www.asktog.com/papers/raskinintuit.html

So how can we "decouple" or code from itself and each other?

---

[![Two coupled high-speed trains ETR 610 of SBB on the Gotthard line](/assets/images/ayoayo/couplings.jpg)](https://www.flickr.com/photos/kecko/33884931711)

*Picture of a train **coupling**.*

---

### decoupling code from shared mutable values

The easiest thing is the obvious thing: If a function shares mutable values with another function (or itself!), and we wish to remove the coupling caused by changes to the shared mutable values, we rewrite the functions to get rid of the shared mutable values. This is an easy refactoring:[^Dependency-Injection]

- We take all of the references to shared mutable values that functions must read, and replace them with parameters.
- We take all of the references to shared mutable values that functions must write, and replace them with creating *copies* of the shared mutable values. We then return those copies along with any other return values the functions already have.

[^Dependency-Injection]: In "How to Deal With Dirty Side Effects in Your Pure Functional Javascript," James Sinclair calls this [Dependency Injection].

[Dependency Injection]: https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/ "How to Deal With Dirty Side Effects in Your Pure Functional Javascript"

So our code becomes:

```javascript
function scoop(before, fromPit) {
  const after = before.slice(0);
  const stonesInHand = after[fromPit];

  after[fromPit] = 0;

  return [after, stonesInHand];
}

function nextPit(pit) {
  return (pit + 1) % 12;
}

function distribute(before, skipPit, currentPit, stonesInHand) {
  const after = before.slice(0);

  if (currentPit === skipPit) {
    currentPit = nextPit(currentPit);
  }

  ++after[currentPit];
  --stonesInHand;

  if (stonesInHand === 0) {
    return [after, currentPit];
  } else if (stonesInHand > 0) {
    return distribute(after, skipPit, nextPit(currentPit), stonesInHand);
  }
}

function sow(before, skipPit, fromPit = skipPit) {
  const [after, pitsInHand] = scoop(before, fromPit);

  return distribute(after, skipPit, nextPit(fromPit), pitsInHand);
}
```

And we use it like this:

```javascript
let gamePits = Array(12).fill(4);

sow(gamePits, 0)
  //=> [
         [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4],
         4
       ]
```

If we want to update the game mutable values, we can choose to do that:

```javascript
let gamePits = Array(12).fill(4);
let lastPit;

[gamePits, lastPit] = sow(gamePits, 0);

gamePits
  //=> [0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4]
```

Well. At first sight, there seem to be more moving parts with this approach.[^well] But in truth, they were always there, it's just that we "lifted" them into the interface of the `scoop`, `distribute`, and `sow` functions where we can see them. And now, we can test any arbitrary invocation without having to remember to set things up in advance.

[^well]: Well, the "elephant in the room" is the creation and abandonment of copies of arrays. There are several ways to address this issue, but for the moment they are not germane to the direction of the essay. But we may return to it later.

For example, here's the second call we made:

```javascript
sow([0, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4], 0, 4)
  //=> [
         [0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 4, 4],
         9
       ]
```

Checks out, and so do the third and fourth calls we made:

```javascript
sow([0, 5, 5, 5, 0, 5, 5, 5, 5, 5, 4, 4], 0, 9)
  //=> [
         [0, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5],
         3
       ]

sow([0, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5], 0, 3)
  //=> [
         [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5],
         9
       ]
```

We get to the same place, but we can run our "tests" in any order and don't have to do any set up in advance.

The lesson learned is that decoupling functions from mutable mutable values makes them easier to understand and test. And if we want to model the "real world" by having a value representing the current game mutable values, we can still do that:

```javascript
let gamePits = Array(12).fill(4);

let initialChoice = 0;
let lastPit;

[gamePits, lastPit] = sow(gamePits, initialChoice);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);
[gamePits, lastPit] = sow(gamePits, initialChoice, lastPit);

gamePits[lastPit]
  //=> 1

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We're now ready to automate the "relay sowing."

---

<iframe width="620" height="349" src="https://www.youtube.com/embed/A4v1WkzY3gA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

*[Relayer] is an album by Prog Rock progenitors Yes. It is notable for being the first album they recorded without Rick Wakeman, who wanted to break from the emphasis on long-form compositions.*

[Relayer]: https://en.wikipedia.org/wiki/Relayer

---

### relay sowing

We have implemented "relay sowing" by hand above. It's time to write a `relaySow` function. We could modify `sow`, but accreting new functionality on top of old is a recipe for bloat.

How do we start `relaySow`? Well, with `sow`:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  // what happens next?
}
```

Well, what **does** happen next? I think we know the answer: We need to check and see whether the number of stones in the last pit is one or not:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  if (after[lastPit] === 1) {
    return [after, lastPit];
  } else {
    // now what?
  }
}
```

"Now what," indeed. Now what? We can't just call `sow` again and return the result, that won't work if we end up needing to sow a third time. We'd need all sorts of nested `if` statements. Yecch.

We *could* rewrite `relaySow` to have a loop of so kind, maybe `do { ... } while (...)`. But hang on! With `distribute`, we recursively called `distribute` when there was more work to be done. Let's use the same pattern:

```javascript
function relaySow(before, skipPit, currentPit = skipPit) {
  let [after, lastPit] = sow(before, skipPit, currentPit);

  if (after[lastPit] === 1) {
    return [after, lastPit];
  } else {
    return relaySow(after, skipPit, lastPit);
  }
}

let gamePits = Array(12).fill(4);
let lastPit;

[gamePits, lastPit] = relaySow(gamePits, 0);

lastPit
  //=> 9

gamePits
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]
```

We have relay sowing working. What else do we need to model a player's turn?

---

[![Game of Go at Club Saarto](/assets/images/ayoayo/saarto.jpg)](https://www.flickr.com/photos/jlarnos/37641991971)

*Go is a completely different game from the Mancala family, but they share the notion of capturing stones.*

---

### capturing stones

Relay sowing ends when the last stone is placed in an empty hole. In Ayoayo, if that empty hole is on the player's side, they capture all of the stones in the corresponding hole on the opponent's side:

```javascript
function capturedStones(before, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const after = before.slice(0);
    const stones = after[pitOnOpponentsSide];

    after[pitOnOpponentsSide] = 0;

    return [after, stones];
  } else {
    return [before, 0];
  }
}
```

We will try it:

```javascript
const gameStart = Array(12).fill(4);
const startPit = 0;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, captured] = capturedStones(afterSowing, startPit, endPit);

afterTurn
  //=> [0, 6, 6, 0, 1, 6, 6, 6, 6, 1, 5, 5]

endPit
  //=> 9

captured
  //=> 0
```

No stones were captured, because the last pit was pit nine on the other side. How can we get a test case that captures stones? Should we try the numbers at random or in sequence? We don't have to. The starting position of the board is symmetrical under rotation. So if move `0` ends up with the board in a certain layout after sowing, and ending on pit `9`, it follows that choosing `1` should lead to exactly the same layout, but rotated one pit counter-clockwise, and the last pit will be `10`.

Well this makes things easy. If the player chooses to start with `3`, the last pit should be `0`, on the player's own side:

```javascript
const gameStart = Array(12).fill(4);
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, captured] = capturedStones(afterSowing, startPit, endPit);

afterSowing
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 6]

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

endPit
  //=> 0

captured
  //=> 6
```

---

![state of the board after the first player chooses pit three](/assets/images/ayoayo/7.jpg)

*The state of the board after the first player chooses pit three.*

---

If we want to update the game state, we'll need a notion of a "score," and we can change `capturedStones` into `handleCapture`:

```javascript
function handleCaptures(beforeBoard, beforeScore, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const afterBoard = beforeBoard.slice(0);
    const playerNumber = startPit > 5 ? 1 : 0;
    const afterScore = Object.assign(
      beforeScore,
      { [playerNumber]: beforeScore[playerNumber] + beforeBoard[pitOnOpponentsSide] }
    );
    afterBoard[pitOnOpponentsSide] = 0;

    return [afterBoard, afterScore];
  } else {
    return [beforeBoard, beforeScore];
  }
}

const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, scoreAfter] = handleCaptures(afterSowing, scoreStart, startPit, endPit);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

scoreAfter
  //=> {0: 6, 1: 0}
```

Finally, we can assemble sowing and capturing together:

```javascript
function sowAndCapture(beforeBoard, beforeScore, startPit) {
  const [afterSowing, endPit] = relaySow(beforeBoard, startPit);
  const [afterTurn, scoreAfter] = handleCaptures(afterSowing, beforeScore, startPit, endPit);

  return [afterTurn, scoreAfter];
}

const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterTurn, scoreAfter] = sowAndCapture(gameStart, scoreStart, startPit);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

scoreAfter
  //=> {0: 6, 1: 0}
```

We now have *almost* everything we need to referee a game between two players. Not enough to write a program to play on its own, but we almost have enough to get going on—for example—a web site that would allow players to play each other online. So what are we missing?

Two things: Determining when the game is over, and determining which moves are permissible. The former depends upon the latter, so our next step is to determine which moves a player is allowed to make.

---

[![no entry?](/assets/images/ayoayo/no-entry.jpg)](https://www.flickr.com/photos/lee-yoshi/15368560025)

*In Ayoayo, some moves are permitted, and some are prohibited.*

---

### permissible moves

In working out which moves are permissible, we need think of only three rules. First, a player can only choose one of the six pits on their side. We'll call this the set of potential moves. Second, a player can only choose a potential move if that pit has one or more stones in it. We'll call the set of potential moves that also have stones to be the set of possible moves:

```javascript
function potentialMoves(player) {
  if (player === 0) {
    return [0, 1, 2, 3, 4, 5];
  } else {
    return [6, 7, 8, 9, 10, 11];
  }
}
```

Now what about filtering the potential moves down to those that are possible?

```javascript
function possible(pits, pit) {
  return pits[pit] > 0;
}

function possibleMoves(pits, moves) {
  if (moves.length === 0) {
    return moves
  } else {
    const [first, ...rest] = moves;

    if (possible(pits, first)) {
      return [first].concat(possibleMoves(pits, rest));
    } else {
      return possibleMoves(pits, rest);
    }
  }
}
```

We can see this in action from our previous work:

```javascript
const gameStart = Array(12).fill(4);
const scoreStart = { 0: 0, 1: 0 };
const startPit = 3;

const [afterSowing, endPit] = relaySow(gameStart, startPit);
const [afterTurn, scoreAfter] = handleCaptures(afterSowing, scoreStart, startPit, endPit);
const potentialMovesForPlayerOne = potentialMoves(1);
const possibleMovesForPlayerOne = possibleMoves(afterTurn, potentialMovesForPlayerOne);

afterTurn
  //=> [1, 5, 5, 0, 6, 6, 0, 1, 6, 6, 6, 0]

possibleMovesForPlayerOne
  //=> [7, 8, 9, 10]
```

We've covered rules one and two. Before we move on to the third rule, our implementation of `possibleMoves` deserves some commentary.

---

[![Symbolics "old style" keyboard](/assets/images/ayoayo/symbolics.jpg)](https://www.flickr.com/photos/mrbill/5336327890)

*[Symbolics, Inc.][Symbolics] was a computer manufacturer headquartered in Cambridge, Massachusetts, and later in Concord, Massachusetts, with manufacturing facilities in Chatsworth, California. Symbolics designed and manufactured a line of Lisp machines, single-user computers optimized to run the Lisp programming language.*

[Symbolics]: https://en.wikipedia.org/wiki/Symbolics

---

###  wherein we travel back in time to the dawn of functional programming

A very long time ago, many of the functional tools we take for granted today--like `map` and `filter` functions--were first being explored with the [Lisp] programming language.

[Lisp]: https://en.wikipedia.org/wiki/Lisp_(programming_language)

Lisp grew to have a rich set of high-performance datatypes, but in its earliest incarnations, most of its data was built around something called a [cons] cell. A cons cell was a place in memory big enough to hold two pointers. The underlying hardware was such that operations on cons cells were very fast.

[cons]: https://en.wikipedia.org/wiki/cons

Cons cells had two parts, an _address register_, and a _decrement register_. You created a cons cell by _cons-ing_ two values together. You could access the individual parts with two functions, `car` ("contents of address register"), and `cdr` ("contents of decrement register").

This is all very relevant to the style of programming where lists are broken into a "first" and "rest," because lists in those days were represented as singly linked lists of cons cells. A list was stored as a reference to the first cons cell. The `car` of that cell was a pointer to the first item in the list, and the `cdr` was a pointer to the next cons cell in the list, which was identically configured.

The last cons cell in the list would have `null` for its `cdr`, and `null` was a shorthand for the empty list.

Thus, it was ridiculously fast to separate a list into the first and rest. And it was equally fast to compose a list by cons-ing a new element with an existing list. And therefore, plenty of textbooks used ot describe recursive algorithms just like the one in `possibleMoves`.

They were mathematically elegant **and** fast. But today, we are working with arrays. And when we write something like `first, ...rest] = moves`, the system makes a copy of the rest of the array. And later, when we write something like `[first].concat(possibleMoves(pits, rest))`, the system again makes copies of the arrays.

We're only working with six elements at a time, so we can afford to chuckle at the performance implications. But the important takeaway here is not that those old algorithms were slow. They weren't. The important takeaway is that it is important to match algorithms to data structures, because what is fast with one data structure may be slow with another.

And most importantly, if there are two ways to do something, and one is more elegant, it may be possible to find a data structure that makes the elegant approach fast. We should never rush to trade elegance for performance without further investigation.

And now back to rule three.

---

[![three buffalo](/assets/images/ayoayo/buffalo.jpg)](https://www.flickr.com/photos/lorenkerns/10238986875)

*Three buffalo. Aren't they magnificent?*

---

### implementing the third rule, with a digression into encapsulation

The third rule for whether a move is permissible is far more interesting than the first two:

> If a player ends his or her turn with no seeds left in his or her row, the opponent must (if it is possible) choose his move in such a way to bring one or more seeds into the other's row. This scheme is found in many Mancala games, and sometimes referred to as "feeding" the opponent (i.e., save the opponent from starving).

As expressed, this rule is not equivalent to the simpler, "If you can make a move that leaves your opponent with a move, you must." This rule only applies to the situation where the opponent's play leaves them with no stones/seeds on their row. Fine, let's code that.

The first and obvious thing to take into account is that this has no effect if the opponent has one or more pits with stones in them. For that, we'll need a function to determine whether a player has at least one possible move. We'll use the `[first, ...rest]` recursive pattern from above.

After all, a player has at least one possible move out of some set of moves if the first move is possible or if there is at least one possible move out of the remaining moves, right? For the sake of conversation, we'll introduce a slightly new pattern: We'll invoke a named function expression, recursively:

```javascript
function atLeastOnePossibleMove(pits, player) {
  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return (function atLeastOne(pits, moves) {
    if (moves.length === 0) {
      return false;
    } else {
      const [first, ...rest] = moves;

      return pits[first] > 0 || atLeastOne(pits, rest);
    }
  })(pits, row);
}
```

Before we move on to write a `permissibleFilter`, let's look at this pattern. We're combining an [immediately invoked function expression] (or "IIFE") with a [named function expression] (a/k/a "NFE"). This allows us to create what amounts to a recursive expression *inside another function*.

[immediately invoked function expression]: https://en.wikipedia.org/wiki/Immediately-invoked_function_expression
[named function expression]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function

It could also have been written like this:

```javascript
function atLeastOnePossibleMove(pits, player) {
  function atLeastOne(pits, moves) {
    if (moves.length === 0) {
      return false;
    } else {
      const [first, ...rest] = moves;

      return pits[first] > 0 || atLeastOne(pits, rest);
    }
  }

  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return atLeastOne(pits, row);
}
```

Or even like this, a pattern we'll call "flat functions," because they're all in one flat space:

```javascript
function atLeastOne(pits, moves) {
  if (moves.length === 0) {
    return false;
  } else {
    const [first, ...rest] = moves;

    return pits[first] > 0 || atLeastOne(pits, rest);
  }
}

function atLeastOnePossibleMove(pits, player) {
  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return atLeastOne(pits, row);
}
```

Putting `atLeastOne` inside `atLeastOnePossibleMove` serves to "hide" it from other code. Given that we own a text editor and have a "commit bit," such hiding serves as much to communicate our thought that `atLeastOne` is only intended to be used by `atLeastOnePossibleMove`. Encapsulating code like this discourages excessive interdependencies, which reduces coupling.

Using an IIFE is mostly a matter of taste. It's a longstanding JavaScript and Lisp idiom. Using a NFE inside an IIFE to enable recursion is the idiomatic way to create a recursive IIFE, if that's what we want.[^Mockingbird]

[^Mockingbird]: We could also have used a recursive combinator like the [Mockingbird], but that is outside of the scope of this essay.
[Mockingbird]: http://raganwald.com/2018/08/30/to-grok-a-mockingbird.html "To Grok a Mockingbird"

In a high-performance application, there are some issues around whether a nested function is created anew with every invocation. It's certainly the case that if a nested function "closes over" variables from its parent, a new environment must be created on every invocation of its parent.

So if we write this code, it will absolutely consume a little more memory with every invocation of `atLeastOnePossibleMove`:

```javascript
function atLeastOnePossibleMove(pits, player) {
  const row =
    player === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

  return (function atLeastOne(moves) {
    if (moves.length === 0) {
      return false;
    } else {
      const [first, ...rest] = moves;

      return pits[first] > 0 || atLeastOne(rest);
    }
  })(pits, row);
}
```

In this version, `atLeastOne` takes advantage of the enclosed environment to reference the `pits` variable from `atLeastOnePossibleMove`'s scope.

In our original version, it didn't, and thus it is _possible_ for the environment to optimize the original version by hoisting `atLeastOne` outside of `atLeastOnePossibleMove`, in effect rewriting our code in "flat functions" form behind the scenes.[^hoisting]

[^hoisting]: In JavaScript, the term [hoisting][hoistingjs] nearly always refers to the specified behaviour of using function declarations and `var` declarations inside of blocks within a function. They are "hoisted" to the top level of the function. But "hoisting" in programming language implementations also refers to an optimization technique that consists of mechanically discovering when functions could be hoisted outside of their enclosing functions, and then hoisting them invisibly. In some language implementations, functions can be hoisted even when they read (but not write) enclosing variables by rewriting them to use dependency injection, much as we've discussed here.

[hoistingjs]: https://developer.mozilla.org/en-US/docs/Glossary/Hoisting

But when we take advantage of scope, the environment cannot rewrite our code. Does that matter? If performance is not a bottleneck, we should always prefer the code that communicates our intent.

But let's move on and get started on `permissibleFilter`:

```javascript
function permissibleFilter(pits, moves) {
  // the degenerate case
  if (moves.length === 0) {
    return moves;
  }

  const firstMove = moves[1];
  const otherPlayer = firstMove > 5 ? 1 : 0;
  const otherPlayerHasStones =
    atLeastOnePossibleMove(pits, otherPlayer);

  if (otherPlayerHasStones) {
    return moves;
  }

  // Ok, what do we do here?
}
```

We've handled the obvious: If the other player has stones on their side of the board, any of the supplied moves are permissible. But if they don't have any stones on their side of the board, we have to figure out if any of the moves will "feed" them by placing at least one stone on their side of the board.

Sounds like we need another filter function. Here we go:

```javascript
function movesThatFeedTheOtherPlayer(before, moves) {
  // the degenerate case
  if (moves.length === 0) {
    return moves;
  }

  const [first, ...rest] = moves;
  const irrelevantScore = { 0: 0, 1: 0 };
  const [after] = sowAndCapture(before, irrelevantScore, first);
  const otherPlayer = first > 5 ? 0 : 1;
  const otherPlayerHasStonesAfter =
    atLeastOnePossibleMove(after, otherPlayer);

  if (otherPlayerHasStonesAfter) {
    return [first].concat(movesThatFeedTheOtherPlayer(before, rest));
  } else {
    return movesThatFeedTheOtherPlayer(before, rest);
  }
}

const lateGameBoard = [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0];
const potentialMovesForPlayerZero = potentialMoves(0);
const possibleMovesForPlayerZero = possibleMoves(lateGameBoard, potentialMovesForPlayerZero);
const movesThatFeedPlayerOne = movesThatFeedTheOtherPlayer(lateGameBoard, possibleMovesForPlayerZero);

movesThatFeedPlayerOne
  //=> [2]
```

And now we can finish `permissibleFilter`, then put it all together into `permissibleMoves`:

```javascript
function permissibleFilter(pits, moves) {
  // the degenerate case
  if (moves.length === 0) {
    return moves;
  }

  const firstMove = moves[1];
  const otherPlayer = firstMove > 5 ? 0 : 1;
  const otherPlayerHasStones =
    atLeastOnePossibleMove(pits, otherPlayer);

  if (otherPlayerHasStones) {
    return moves;
  } else {
    const permissibleMoves = movesThatFeedTheOtherPlayer(pits, moves);

    if (permissibleMoves.length > 0) {
      return permissibleMoves;
    } else {
      // slightly irrelevant, as the gamne is about to end
      // no matter which move is chosen
      return moves;
    }
  }
}

function permissibleMoves(before, player) {
  const potentialMovesForPlayer = potentialMoves(player);
  const possibleMovesForPlayer = possibleMoves(lateGameBoard, potentialMovesForPlayer);
  const permissibleMovesForPlayer = permissibleFilter(lateGameBoard, possibleMovesForPlayer);

  return permissibleMovesForPlayer;
}

const lateGameBoard = [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0];

permissibleMoves(lateGameBoard, 0)
  //=> [2]
```

Whew! We're almost done writing the things we would need to handle game mechanics if we were writing an Ayoayo game. The final thing is the end condition. If a player has no stones in their row at the beginning of their turn, their opponent collects all of the stones left on the board, and the game ends.

Let's implement that.

---

[![A whole new view of the Crab Nebula](/assets/images/ayoayo/crab.jpg)](https://www.flickr.com/photos/hubble_esa/22823588348)

*Everything ends, not just games, but even stars: In 1054 AD, during the Song dynasty, Chinese astronomers spotted a bright new star in the night sky. This newcomer turned out to be a violent explosion within the Milky Way, caused by the spectacular death of a star some 1600 light-years away. This explosion created one of the most well-studied and beautiful objects in the night sky--the Crab Nebula. ([More information][crabinfo].)*

[crabinfo]: www.spacetelescope.org/images/potw1644a/

---

### ending the game

We said above that "If a player has no stones in their row at the beginning of their turn, their opponent collects all of the stones left on the board, and the game ends." That is equivalent to saying that "If, after making a permissible move, your opponent's row is empty, you capture all of the stones in your row, and then the game ends."

Put that way, we don't need a brand new function, we can update `handleCaptures`. That function is already big enough and has one clear responsibility, handling the ordinary kind of capture. So let's extract that and make it a helper, then write a new function to handle captures after completing a turn:

```javascript
function handleCapturesInTurn(beforeBoard, beforeScore, startPit, endPit) {
  const endedOnThePlayersSide = startPit < 6 === endPit < 6;

  if (endedOnThePlayersSide) {
    const pitOnOpponentsSide = 11 - endPit;
    const afterBoard = beforeBoard.slice(0);
    const playerNumber = startPit > 5 ? 1 : 0;
    const afterScore = Object.assign(
      beforeScore,
      { [playerNumber]: beforeScore[playerNumber] + beforeBoard[pitOnOpponentsSide] }
    );
    afterBoard[pitOnOpponentsSide] = 0;

    return [afterBoard, afterScore];
  } else {
    return [beforeBoard, beforeScore];
  }
}

function handleGameEnd(beforeBoard, beforeScore, playerWhoJustMoved) {
  // Write function here!
}

function handleCaptures(beforeBoard, beforeScore, startPit, endPit) {
  const [afterCapturesInTurn, afterScoreInTurn] =
    handleCapturesInTurn(beforeBoard, beforeScore, startPit, endPit);
  const playerWhoJustMoved = startPit > 5 ? 1 : 0;
  const [afterTurn, afterScore] = handleGameEnd(afterCapturesInTurn, afterScoreInTurn, playerWhoJustMoved);
  const isOver = (afterScore[0] + afterScore[1]) === 48;

  return [afterTurn, afterScore, isOver];
}

function sowAndCapture(beforePits, beforeScore, startPit) {
  const [afterSowing, endPit] = relaySow(beforePits, startPit);
  const [afterTurn, scoreAfter, isOver] = handleCaptures(afterSowing, beforeScore, startPit, endPit);

  return [afterTurn, scoreAfter, isOver];
}
```

And now let's write `handleGameEnd`. For starters, we check whether the other player has moves, if they do, there is no effect:

```javascript
function handleGameEnd(beforeBoard, beforeScore, playerWhoJustMoved) {
  const otherPlayerNumber = 1 - playerWhoJustMoved;
  const otherPlayerHasMoves = atLeastOnePossibleMove(beforeBoard, otherPlayer);

  if (otherPlayerHasMoves) {
    return [beforeBoard, beforeScore];
  } else {
    // Capture everything else!
  }
}
```

If they don't, we capture every stone on the player's side. We can gratuitously use our IIFE/NFE recursion pattern again, with a twist:

```javascript
function handleGameEnd(beforeBoard, beforeScore, playerWhoJustMoved) {
  console.log({beforeBoard, beforeScore, playerWhoJustMoved})
  const otherPlayer = 1 - playerWhoJustMoved;
  const otherPlayerHasMoves = atLeastOnePossibleMove(beforeBoard, otherPlayer);

  if (otherPlayerHasMoves) {
    return [beforeBoard, beforeScore];
  } else {
    const playerPits =
      playerWhoJustMoved === 0 ? [0, 1, 2, 3, 4, 5] : [6, 7, 8, 9, 10, 11];

    const stonesRemaining = (function countStones(board, pits, runningTotal = 0) {
      if (pits.length === 0) {
        return runningTotal;
      } else {
      	const [first, ...rest] = pits;

      	return countStones(board, rest, runningTotal + board[first]);
      }
    })(beforeBoard, playerPits);

    const playerWhoJustMovedScore = beforeScore[playerWhoJustMoved] + stonesRemaining;

    const finalScore = {
      [playerWhoJustMoved]: playerWhoJustMovedScore,
      [otherPlayer]: beforeScore[otherPlayer]
    };

    return [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      finalScore
    ];
  }
}
```

And we can do an "integration test," running our code from end to end:

```javascript
const lateGameBoard = [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0];
const lateGameScore = { 0: 40, 1: 5 };

let [afterTurn, afterScore, isOver] = sowAndCapture(lateGameBoard, lateGameScore, 2);

afterTurn
  //=> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

afterScore
  //=> { 0: 43, 1: 5 }

isOver
  //=> true

const notOverBoard = [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0];
const notOverScore = { 0: 39, 1: 5 }

[afterTurn, afterScore, isOver] = sowAndCapture(notOverScore, lateGameScore, 2);

afterTurn
  //=> [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]

afterScore
  //=> { 0: 39, 1: 5 }

isOver
  //=> false
```

We've gathered the basic building blocks for writing a program that could, for example, facilitate a game between two players over the Internet, or via pass-and-play on a tablet.

---

*to be completed*

---

[![code.close()](/assets/images/ayoayo/code.jpg)](https://www.flickr.com/photos/ruiwen/3260094840)

---

# Appendix: The completed code

<script src="https://gist.github.com/raganwald/d55012c262c02d769054f70f55a1032e.js"></script>


---

# Notes